> [!info] **Основная идея**  
> **Garbage Collector Go 1.24.5** — малопаузный трёхцветный *(tri-color)* concurrent **mark-and-sweep**, который запускается, когда «новая куча» достигает величины ≈ *GOGC %* от объёма живых объектов. Благодаря алгоритму *pacemaker* паузы **stop-the-world** сокращены до десятков микросекунд. Грамотный тюнинг GC позволяет удерживать RSS контейнера в пределах лимитов, уменьшать пиковое потребление памяти и избегать OOM-киллов.

---

## Краткий конспект
* **Где живут данные**: стек vs куча, *escape analysis*.  
* **Три цвета** GC и две короткие STW-фазы.  
* **Порог GOGC** и ручной тюнинг (`debug.SetGCPercent`).  
* **GOMEMLIMIT** — жёсткая рамка для контейнеров.  
* **sync.Pool** для снижения аллокаций.  
* **Когда уместен `runtime.GC()`**.  
* **Сравнение с Python / Java** — паузы и предсказуемость.

---

## Подробно

### 1. Где живут данные в Go
Go размещает данные либо на **стеке** горутины, либо в **куче** процесса.  
Аллокатор выбирает область, запуская **escape-analysis** во время компиляции:

* значение не уходит за пределы функции → стек (практически бесплатное);  
* значение «утекает» → куча → управляется GC.

```go
// mini-benchmark: go test -bench=. -benchmem
func BenchmarkEscape(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = &[1024]byte{} // утекает => heap
	}
}
````

> [!example]  
> Используйте `go test -gcflags="-m"` для просмотра отчёта escape-analysis.

---

### 2. Как устроен трёхцветный GC

|Цвет|Состояние|Действия|
|---|---|---|
|**Белый**|Не посещён → кандидат на удаление|После sweep память возвращается аллокатору|
|**Серый**|Посещён, но дети не обработаны|Попадает в work-queue для маркеров|
|**Чёрный**|Объект и дети посещены|Гарантированно сохранится|

Алгоритм идёт параллельно с миром:

1. **STW-1 (root scan, 50–100 µs)** — мир останавливается, корни становятся серыми.
    
2. **Concurrent mark** — работает фоновый маркер.
    
3. При достижении целевого debt — **Concurrent sweep** очищает белые чанки.
    
4. **STW-2 (termination, ≈ 25 µs)** закрывает проход, обновляет статистику.
    

> [!tip]  
> Механизм _pacemaker_ регулирует скорость маркеров так, чтобы пройти раньше «heap goal». Это даёт микропаузный GC без ручного тюнинга.

---

### 3. Порог GOGC и тюнинг

Параметр **GOGC** — целевой рост кучи в % к live-set после последней GC-паузы.

|GOGC|Сборок/с|CPU GC %|Max RSS|
|---|---|---|---|
|10|≈ 200|≈ 30 %|низкий|
|100|≈ 10|≈ 2–4 %|средний|
|1000|< 1|≈ 0.5 %|высокий|

```go
debug.SetGCPercent(50) // эквивалент GOGC=50
```

> [!warning] Подводный камень  
> При GOGC < 20 на write-heavy нагрузке (10 k+ allocs/s) GC может занять до 30 % CPU.

---

### 4. Полное отключение GC

`GOGC=off` или `debug.SetGCPercent(-1)` останавливает автоматический GC.  
Ручной вызов `runtime.GC()` остаётся.

_Когда оправдано_: короткоживущие batch-задачи, завершающиеся до переполнения памяти.  
_Почему опасно_: любая утечка памяти → рост RSS → OOM.

---

### 5. Лимиты памяти контейнера

Переменная **GOMEMLIMIT** (Go 1.20+) задаёт верхнюю границу heap + stack:

```bash
GOMEMLIMIT="900MiB" ./server
```

Если лимит достигнут, pacemaker снижает GOGC, ускоряя сборку.  
Если и это не помогает — аллокатор паникует `runtime: out of memory`.

> [!example]  
> **Kubernetes Pod**
> 
> ```yaml
> env:
>   - name: GOMEMLIMIT
>     value: "90%"
> ```

---

### ### 6. Приёмы уменьшения аллокаций

Память в Go распределяется быстро, но _каждое_ выделение увеличивает объём работы сборщика мусора.  
Чем меньше аллокаций — тем ниже _alloc/op_, короче паузы GC и выше пропускная способность.  
Ниже приведены два популярных приёма, которые позволяют существенно сократить число выделений без потери читаемости кода.

---

#### `sync.Pool`

`sync.Pool` — это конкурентно-безопасный контейнер «бери-клади» для временных объектов.

```go
var bufPool = sync.Pool{
	New: func() any { return make([]byte, 0, 4096) }, // выделяется только при исчерпании пула
}

b := bufPool.Get().([]byte) // может вернуться nil, проверяйте при необходимости
// … используем b как рабочий буфер …
bufPool.Put(b[:0])          // длину обнуляем, чтобы потребитель видел «пустой» срез
```

**Как это работает**

- У каждого `P` (планировщика) есть собственный локальный суб-пул.  
    В типичных high-load сценариях это означает _lock-free_ получение/возврат объектов.
    
- После завершения цикла сборки мусора _весь_ пул может быть очищен; он **не** гарантирует кэширование «навсегда».
    
- Объект, помещённый в `sync.Pool`, должен быть **полностью переинициализирован** перед повторным использованием — пул _ничего_ не обнуляет за вас.
    

**Когда использовать**

1. **Короткоживущие буферы** (IO-пайплайны, JSON/YAML парсеры, proto-кодеки).
    
2. **Временные структуры** (например, `bytes.Buffer`, `bufio.Writer`) в запрос-ответ-ориентированном коде.
    
3. Высокочастотные аллокации, где замена на pre-allocated срез или `sync.Pool` проще, чем рефакторинг алгоритма.
    

**Чего избегать**

- **Долгоживущих** или редко используемых объектов — пул начнёт «вытеснять» их после GC, пользы не будет.
    
- Хранения в пуле _указателей_, которыми владеют другие горутины; легко получить _use-after-free_.
    
- Попыток использовать `sync.Pool` как общий кэш: для кеширования лучше подходит `expvar`, `ristretto`, `groupcache` и т. д.


> [!tip]  
> После **каждого** изменения `GOGC`, `GOMEMLIMIT`, внедрения `sync.Pool
> 
> ```bash
> go test -bench . -benchmem
> ```
> 
> и следите за _alloc/op_, _ns/op_ и _pause ns_. Без метрик оптимизация — гадание на кофейной гуще.
---

### 7. Сравнение с Python и Java

|Язык|Тип GC|STW p95|Настройка по умолчанию|
|---|---|---|---|
|Go|tri-color, concurrent|30–100 µs|GOGC = 100|
|Java|G1 (региональный)|5–50 ms|Xms/Xmx обязательны|
|Python|ref-count + cyc-GC|< 1 ms / цикл, частые|Threshold ~ 700|

**Вывод**: Go демонстрирует самые короткие предсказуемые паузы «из коробки».

---

## Итоговые выжимки

- **Escape-анализ** → стек, нулевые паузы.
    
- **Три цвета + pacemaker** → микропаузный GC.
    
- **GOGC** — главный рычаг «CPU ↔ Memory».
    
- **GOMEMLIMIT** держит контейнеры в узде.
    
- **sync.Pool уменьшают кратковременные аллокации.
    
- **Отключать GC в проде** почти никогда не стоит.
    

---

> [!faq]  
> **Q:** Когда вызывать `runtime.GC()` вручную?  
> **A:** В CLI-утилитах после большого шага (например, распаковки архива). В долгоживущем сервисе — почти никогда.  
> 
> **Q:** Стоит ли ставить GOGC > 1000?  
> **A:** Только если много свободной памяти и CPU дорог, но риск OOM выше.  
> 
> **Q:** Как измерить эффект от `sync.Pool`?  
> **A:** Сравнить _alloc/op_ и _pause ns/op_ в бенчмарке до/после + `pprof heap`.

---

## Заключение

GC Go 1.24.5 — зрелый, малопаузный и в большинстве случаев не требует ручной настройки.  
Однако понимание **GOGC, GOMEMLIMIT помогает держать RSS и CPU-cost под контролем. Измеряйте метрики (_bench + pprof_) — это надёжнее любых «магических» значений.

---

## Полезные ссылки

- [https://go.dev/doc/gc-guide](https://go.dev/doc/gc-guide)
    
- [https://go.dev/doc/manage-memory](https://go.dev/doc/manage-memory)
    
- [https://pkg.go.dev/runtime/debug#SetGCPercent](https://pkg.go.dev/runtime/debug#SetGCPercent)
    
- [https://github.com/golang/go/wiki/Memory](https://github.com/golang/go/wiki/Memory)
