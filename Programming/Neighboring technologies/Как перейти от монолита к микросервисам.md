> [!info] Основная идея  
> Переход от монолита к микросервисной архитектуре позволяет масштабировать систему, уменьшить связанность компонентов и ускорить выпуск новых фич. В экосистеме Go это особенно эффективно благодаря высокой производительности, простоте деплоя и зрелым инструментам для сервисной архитектуры.

---

## Краткий конспект

★ Оценка текущей архитектуры и выявление проблем масштабирования.  
★ Планирование миграции, выбор стратегии (Strangler, Parallel Run).  
★ Настройка инфраструктуры: Docker, [[Kubernetes]], CI/CD, observability.  
★ Автоматизация деплоя и маршрутизации: ingress, сервисная сетка.  
★ Преимущества: масштабируемость, независимость команд, отказоустойчивость.  
★ Потенциальные сложности: транзакционность, мониторинг, координация изменений.

---

## Подробно

### Когда стоит переходить?

- Рост команды или скорости разработки замедляет выпуск фич.
    
- Компоненты приложения конфликтуют по масштабируемости или SLA.
    
- Монолит не укладывается в ограничения по времени билда или CI.
    
- Команда хочет внедрить независимые языки/технологии для разных задач.
    

> [!tip] Не стоит переходить на микросервисы только потому, что "так делают все". Начинайте только при наличии реальных болей и ресурса на поддержку новой архитектуры.

---

### Этап 1: Анализ монолита и выделение bounded contexts

- Проведите анализ текущей кодовой базы.
    
- Составьте карту зависимостей между модулями.
    
- Используйте подход [[DDD]]: определите бизнес-контексты и их границы.
    
- Начинайте с самых изолируемых и зрелых компонентов.
    

> [!example] Если у вас e-commerce, можно первым выделить сервис каталогов, т.к. он часто отделён от логики заказов и платежей.

---

### Этап 2: Подготовка инфраструктуры (Docker, Kubernetes, CI/CD, сервисная сетка)

- Оберните каждый будущий сервис в Docker-образ.
    
- Настройте окружения через Kubernetes.
    
- Настройте CI/CD пайплайн (GitHub Actions, GitLab CI, ArgoCD).
    

> [!tip] Для Go удобны минимальные образы (`scratch` или `alpine`) с мультистейдж-сборкой. Это ускоряет сборку и повышает безопасность.

---

### Этап 3: Стратегии миграции (Strangler Fig, Parallel Run, Decomposition by Business Capability)

- **Strangler Fig Pattern** — постепенно заменяйте модули монолита микросервисами.
    
- **Parallel Run** — запускайте новый сервис параллельно и сравнивайте результаты.
    
- **Decomposition by Capability** — выделяйте сервисы по бизнес-функциям, а не слоям архитектуры.
    

> [!warning] Распараллеливание с Parallel Run требует двойного источника правды и синхронизации состояний.

> [!example] Используйте reverse proxy (например, Envoy) для направления части трафика к новому микросервису.

---

### Этап 4: Реализация сервисов на Go

- Стартуйте с REST или gRPC API, в зависимости от требований.
    
- Выделите контракты данных через `.proto` или OpenAPI.
    
- Используйте библиотеки: chi, grpc-go, zap/logrus.
    

```
// Пример gRPC-сервиса на Go
service OrderService {
  rpc CreateOrder (OrderRequest) returns (OrderResponse);
}
```

> [!tip] Go хорош тем, что легко собирать минимальные сервисы с небольшим временем отклика и простым деплоем в k8s.

---

### Этап 5: [[Observability]] — логирование, трассировка и метрики

- Логируйте в stdout, используйте structured logging (zap, zerolog).
    
- Внедрите трассировку (OpenTelemetry, Jaeger).
    
- Собирайте метрики (Prometheus + Grafana).
    

---

### Этап 6: [[Тестирование и анализ качества|Тестирование]] и плавный вывод монолита из эксплуатации

- Покрывайте каждый сервис unit и интеграционными тестами.
    
- Используйте контрактное тестирование между сервисами.
    
- Отключайте части монолита только после стабилизации микросервисов.
    

> [!warning] Не удаляйте код из монолита до полной уверенности, что миграция успешна, и нет скрытых зависимостей.

---

> [!faq] **Q:** Нужно ли сразу переписывать весь монолит? **A:** Нет. Начинайте поэтапно, лучше с сервиса, который имеет чёткие границы и минимальные зависимости.
> 
> **Q:** Что использовать для общения между сервисами? **A:** Внутри — gRPC или REST; между доменами — событийные очереди (Kafka, NATS).
> 
> **Q:** Как избегать дублирования бизнес-логики? **A:** Стандартизируйте API и поддерживайте shared contracts через `.proto` или OpenAPI.

---

## Полезные ссылки

Вот те же ссылки, оформленные в формате Obsidian-Markdown:

- [обзор стратегий миграции (2025)](https://acropolium.com/blog/migrating-monolith-to-microservices/)
- [DevOps best practices](https://edgedelta.com/blog/migrating-from-monolith-to-microservices)
- [визуальные паттерны перехода](https://blog.bytebytego.com/p/from-monolith-to-microservices-key)
- [go-kit — официальный сайт](https://go-kit.dev/)
- [gRPC на Go — quickstart](https://grpc.io/docs/languages/go/quickstart/)
- [OpenTelemetry в Go — трассировка](https://opentelemetry.io/docs/instrumentation/go/)

