# Паттерны микросервисов в Go — коротко и простым языком

Микросервисы — это когда вместо одного большого приложения у нас много маленьких сервисов. Каждый делает свою часть работы и общается с другими по сети. Ниже — три самых полезных паттерна, объяснённых простыми словами и без лишней теории.

---

## 1) API Gateway (или BFF — «Backend for Frontend»)

**Идея в двух словах:** одна входная дверь для всех клиентов.

Представьте торговый центр: чтобы попасть в любой магазин, вы заходите через общий вход. **API Gateway** — это такой вход для ваших сервисов. Клиент (веб‑приложение или мобильное) стучится в Gateway, а тот уже знает, к какому внутреннему сервису отправить запрос, как его собрать и как вернуть ответ.

**Что он делает:**

- проверяет токен/логин;
    
- направляет запрос в нужный сервис;
    
- может объединить ответы нескольких сервисов в один;
    
- ставит ограничения по запросам (чтобы никто не «сломал» систему);
    
- ведёт логи и метрики.
    

**Когда это нужно:**

- у вас много сервисов, а клиентам хочется простой и стабильный внешний API;
    
- один экран/страница собирается из данных разных сервисов;
    
- нужна единая точка для авторизации, троттлинга и кэша.
    

**О чём помнить:**

- не превращайте Gateway в «толстый» слой с бизнес‑логикой;
    
- сделайте его отказоустойчивым (несколько экземпляров + балансировщик).
    

---

## 2) Saga + Outbox (надёжные цепочки действий)

**Идея в двух словах:** сложная операция раскладывается на шаги, у каждого шага есть обратный шаг «откат».

Допустим, пользователь оформляет заказ. Нужно: создать заказ, списать деньги, уменьшить остатки на складе. Если где‑то посередине произошла ошибка, нельзя оставить систему в «полупротиснутом» состоянии. **Saga** решает это так:

- делим процесс на маленькие локальные операции (каждый сервис делает свою часть);
    
- после успешной операции отправляем событие следующему сервису («заказ создан», «резерв выполнен» и т. п.);
    
- если что‑то пошло не так, запускаем **компенсацию** — обратное действие (например, отменить резерв, вернуть деньги).
    

**Зачем тут Outbox:**  
Иногда сервис успел записать данные в свою БД, но событие о том, что «всё готово», ещё не улетело в брокер (или наоборот). **Outbox** — это «исходящая коробка» в той же базе: мы сначала сохраняем событие рядом с данными в одной транзакции, а отдельный «почтальон» потом надёжно отправляет эти события наружу. Так мы не теряем сообщения.

**Когда это нужно:**

- одна бизнес‑функция затрагивает несколько сервисов;
    
- важна целостность: либо вся цепочка прошла, либо всё аккуратно откатилось.
    

**О чём помнить:**

- события могут приходить дважды — обработка должна быть безопасной от повторов;
    
- наблюдаемость решает: логи корреляции, трассировка запросов, дашборды.
    

---

## 3) Circuit Breaker (предохранитель)

**Идея в двух словах:** если соседний сервис «горит», не подливайте масла в огонь.

Иногда зависимость начинает тормозить или падать. Если продолжать стучаться к ней тысячами запросов, вы только ухудшите ситуацию и заблокируете свои ресурсы. **Circuit Breaker** — это «предохранитель», который на время **размыкает цепь**:

- если много ошибок подряд — «выключаем» вызовы к зависимому сервису и сразу отдаём ошибку или простой фолбэк (например, кэш);
    
- через короткие промежутки пробуем «прощупать» зависимость одним запросом: если всё ок, снова включаем трафик.
    

**С этим всегда идут рядом:**

- **таймауты** (не ждём ответа бесконечно);
    
- **ретраи с паузами** (пробуем ещё раз, но недолго и не бесконечно);
    
- **фолбэки** (кэшированный ответ, сохранённый черновик и т. п.).
    

**Когда это нужно:**

- у вас есть внешние или нестабильные зависимости (платёжки, внешние API, медленные сервисы);
    
- важнее быстро и предсказуемо отвечать, чем иногда очень долго ждать.
    

---

## Как это выглядит вместе

1. Клиент ходит **только** в API Gateway — просто и безопасно.
    
2. Внутри бизнес‑операции запускается **Saga** — шаг за шагом, с событиями и возможностью отката.
    
3. Все исходящие вызовы закрыты **таймаутами** и **Circuit Breaker**, чтобы система не «падала доминошками».
    

---

## Короткий чек‑лист

-  У Gateway есть проверка прав, ограничение запросов и логи.
    
-  Сложные операции разбиты на шаги; предусмотрены компенсирующие действия.
    
-  События отправляются через Outbox, чтобы ничего не потерять.
    
-  Исходящие вызовы имеют таймауты, ретраи и предохранитель.
    
-  Метрики и алерты настроены: время ответа, ошибки, состояние breaker.
    

---

## Почему это удобно в Go

- Простые и быстрые HTTP‑сервера из коробки.
    
- Удобный `context` для таймаутов и отмены запросов.
    
- Много лёгких библиотек для брокеров сообщений, breaker и backoff.
    

---

## Итог

Три паттерна — **API Gateway**, **Saga+Outbox** и **Circuit Breaker** — закрывают три главные задачи микросервисов: единый вход, надёжные сквозные операции и устойчивость к сбоям. Начните с них: сделайте вход через Gateway, оформите сложные сценарии как Saga с Outbox, а все внешние вызовы — через таймауты и предохранитель. Так система останется понятной, быстрой и живучей.