# Планировщик горутин Go (GMP) и работа с потоками

> [!info] **Основная идея**  
> На уровне ОС есть **процессы**, процессы содержат **потоки** (kernel threads), а планировщик ядра распределяет эти потоки по **логическим (виртуальным) ядрам**.  
> В Go всё усложняется рантаймом: тредами управляет ОС, а **горутинами** — собственный планировщик, основанный на модели **G-M-P**.

---

## Процессы → Потоки → Ядра

- Планировщик ядра оперирует **потоками**, а не процессами.  
- Логическое ядро ≠ поток: это «место», куда планировщик может посадить *любой* поток.  
- Приложение создаёт потоки, планировщик решает, где и когда их запускать.

> [!tip]  
> «Процессы → потоки → ядра» — полезная, но упрощённая модель. В реальности ОС планирует *потоки*, а Go-рантайм перепланирует *горутины* внутри потоков.

---

## Параллельность vs. Конкурентность

![[Pasted image 20250804040848.png]]

---

## Модель **G-M-P** (Goroutine • Machine • Processor)

| Компонент | Что это | Ключевые детали |
|-----------|---------|-----------------|
| **G (goroutine)** | Лёгкий контекст выполнения | Собственный стек, параметры, PC |
| **M (machine)**   | Поток ОС | Выполняет код горутин |
| **P (processor)** | Логический процессор Go | Держит *локальную очередь* G, планирует их на M |

### Очереди

- **Локальная** очередь у каждого `P` — FIFO + LIFO (последняя добавленная — в LIFO).  
- **Work-stealing**: если очередь пуста, воруется **половина** задач у случайного соседа.  
- Каждые 61 итерацию `P` берёт задачу из **глобальной** очереди (magic 1/61).

![[Pasted image 20250804044547.png]]

![[Pasted image 20250804045030.png]]

---

## Системные вызовы и netpoller

> [!tip] **Системный вызов**  
> Когда горутина делает sys-call, рантайм переводит её в **новый поток M**, чтобы не блокировать `P`.  
> Освободившийся `P` берёт другую горутину.

- **netpoller** (обёртка над `epoll`) паркует сетевые горутины, не блокируя `M`.  
- После события горутина кладётся в **глобальную** очередь.

---

## Sysmon

`sysmon` следит, чтобы горутина не работала > 10 ms без парка, и запускает GC.

---

## Итог

- Горутинами управляет Go-рантайм.  
- GMP скрывает всю механику под капотом.  
- Системные/сетевые вызовы обрабатываются особым образом, чтобы не блокировать планирование.

---

> [!faq]  
> **Q:** Что такое модель GMP в трёх словах?  
> **A:** *Goroutines → Processors → OS-threads*. Горутины (`G`) планируются на виртуальные процессоры (`P`), а те, в свою очередь, исполняются потоками ОС (`M`).  
>  
> **Q:** Зачем нужен «magic 1/61»?  
> **A:** Чтобы `P` периодически проверял **глобальную** очередь и не допускал голодания горутин, которых туда положили после sys-call или netpoller.  
>  
> **Q:** Что произойдет, если горутина зависнет на sys-call?  
> **A:** Рантайм выделит **новый поток** `M` и перенесёт туда заблокированную горутину, чтобы `P` не простаивал.  
>  
> **Q:** Есть ли смысл увеличивать `GOMAXPROCS` больше количества логических ядер?  
> **A:** Нет — лишние `P` будут простаивать, только растёт оверхед.  
>  
> **Q:** Чем `P` отличается от scheduler-thread в других рантаймах?  
> **A:** `P` хранит состояние планировщика (очередь G, ссылка на run-queue GC и т.д.); поток `M` захватывает `P` лишь на время выполнения.

---

## Полезные ссылки

- **Документация Go** — пакет `runtime`  
- *Go Scheduler* (blog.cloudflare.com)  
- [[Черновой вариант статьи Планировщик]]