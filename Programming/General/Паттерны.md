> [!info] **Основная идея**  
> Порождающие паттерны проектирования — это стратегии управления созданием объектов. В Go, благодаря статической типизации и явной инициализации, паттерны **Factory**, **Singleton** и **Builder** адаптированы под особенности языка и широко используются в библиотеке стандартных интерфейсов, DI и сетевых приложениях.

---

## Краткий конспект

- **Factory Method** — предоставляет интерфейс для создания объектов, позволяя делегировать выбор конкретной реализации.
- **Singleton** — гарантирует, что существует только один экземпляр объекта, и предоставляет к нему глобальную точку доступа.
- **Builder** — позволяет пошагово настраивать сложные структуры, отделяя их создание от представления.

---

## Подробно

### Factory Method

#### Что это такое и когда применять

**Factory Method** используется, когда клиентский код должен создавать объекты, но не должен зависеть от конкретных типов этих объектов. Это особенно актуально, когда:

- реализации могут изменяться;
- нужно обеспечить расширяемость;
- требуется создавать интерфейсные значения.

#### Как реализовать в Go

> [!example] Мини-пример кода  
> ```go
> type Transport interface {
>     Deliver()
> }
>
> type Truck struct{}
>
> func (Truck) Deliver() {
>     fmt.Println("Deliver by truck")
> }
>
> func NewTransport(kind string) Transport {
>     switch kind {
>     case "truck":
>         return Truck{}
>     default:
>         return nil
>     }
> }
> ```

#### Преимущества и недостатки

✅ Инкапсуляция логики создания  
✅ Расширяемость  
❌ Возможная сложность при большом количестве вариантов  
❌ Нет строгой защиты от ошибок в `switch`

#### Практический сценарий

Создание объектов хранения (`Storage`) с разной реализацией: `S3`, `Local`, `GCS`.

> [!warning] Подводные камни  
> - Слишком много `if`/`switch` в фабрике — признак нарушения SRP.  
> - Возврат `nil` без ошибок затрудняет отладку.  
> - Часто смешивают Factory и Abstract Factory.

---

### Singleton

#### Что это такое и когда применять

**Singleton** гарантирует наличие только одного экземпляра структуры. В Go применяется, например, для конфигураций, логгеров, подключения к БД.

#### Реализация с `sync.Once`

```go
type Config struct {
    Port int
}

var (
    instance *Config
    once     sync.Once
)

func GetConfig() *Config {
    once.Do(func() {
        instance = &Config{Port: 8080}
    })
    return instance
}
````

#### Плюсы и минусы

✅ Потокобезопасность  
✅ Централизованная инициализация  
❌ Неудобно тестировать (глобальное состояние)  
❌ Может стать анти-паттерном при чрезмерном использовании

#### Практический сценарий

Логгер, который конфигурируется один раз при старте приложения и затем используется во всём проекте.

> [!warning]
> 
> - Не используйте `init()` для реализации Singleton — трудно контролировать порядок.
>     
> - Глобальные синглтоны нарушают инверсию зависимостей.
>     
> - Избегайте мутабельных синглтонов.
>     

---

### Builder

#### Что это такое и когда применять

**Builder** нужен для создания объектов со множеством опциональных параметров. В Go часто реализуется через паттерн **Functional Options**.

#### Реализация через структуры

```go
type Server struct {
    Host string
    Port int
}

type ServerBuilder struct {
    host string
    port int
}

func (b *ServerBuilder) Host(h string) *ServerBuilder {
    b.host = h
    return b
}

func (b *ServerBuilder) Port(p int) *ServerBuilder {
    b.port = p
    return b
}

func (b *ServerBuilder) Build() *Server {
    return &Server{Host: b.host, Port: b.port}
}
```

#### Реализация через Functional Options

```go
type Server struct {
    Host string
    Port int
}

type Option func(*Server)

func WithHost(h string) Option {
    return func(s *Server) { s.Host = h }
}

func WithPort(p int) Option {
    return func(s *Server) { s.Port = p }
}

func NewServer(opts ...Option) *Server {
    s := &Server{Host: "localhost", Port: 80}
    for _, opt := range opts {
        opt(s)
    }
    return s
}
```

#### Плюсы и минусы

✅ Гибкость  
✅ Лёгкая читаемость  
✅ Без необходимости большого числа конструкторов  
❌ Сложнее отследить дефолтные значения  
❌ Не всегда понятно, какие поля обязательны

#### Практический сценарий

Создание клиента к HTTP API с необязательной авторизацией, таймаутами и прокси.

> [!warning]
> 
> - Внимательно документируйте поведение опций.
>     
> - Избегайте модификаций после `Build()`.
>     
> - Functional Options сложно комбинировать с валидацией.
>     

---

> [!tip] Рекомендации
> 
> - Используй `sync.Once` для безопасной инициализации Singleton.
>     
> - Разделяй интерфейс и реализацию в фабриках.
>     
> - Для Builder в Go предпочтителен стиль [[Functional Options]].
>     
> - Паттерны — инструмент, а не догма: выбирай по задаче.
>     

---

> [!faq] Часто задаваемые вопросы  
> **Q:** Стоит ли использовать паттерны в Go, если можно обойтись без них?  
> **A:** Да, если они упрощают код и делают его читаемее — особенно в больших проектах.
>
> **Q:** Есть ли встроенная поддержка паттернов в Go?  
> **A:** Нет — Go предоставляет простые механизмы, из которых можно построить нужный паттерн.
>
> **Q:** Можно ли использовать Factory и Builder одновременно?  
> **A:** Да — Factory может возвращать Builder-объект, например, для конфигурации клиента.
