/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  FileAndDirChooser: () => FileAndDirChooser,
  default: () => CrosslinkAdvanced
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// obsidian-reusables/src/indexFiles.ts
var import_obsidian = require("obsidian");
function isIndexFile(file) {
  var _a;
  return file instanceof import_obsidian.TFile && file.basename === ((_a = file.parent) == null ? void 0 : _a.name);
}
function parentPrefix(file) {
  return folderPrefix(file.parent);
}
function folderPrefix(file) {
  return file.path === "/" ? "" : `${file.path}/`;
}
async function forceFolder(file, app) {
  if (file instanceof import_obsidian.TFile) {
    if (isIndexFile(file)) {
      return { folder: file.parent, index: file };
    }
    const fileParentPrefix = parentPrefix(file);
    const folder = await app.vault.createFolder(
      fileParentPrefix + file.basename
    );
    const indexPath = `${folder.path}/${file.name}`;
    await app.fileManager.renameFile(file, indexPath);
    return {
      folder,
      index: app.vault.getAbstractFileByPath(indexPath)
    };
  }
  if (file instanceof import_obsidian.TFolder) {
    const indexPath = `${file.path}/${file.name}`;
    return {
      folder: file,
      index: app.vault.getAbstractFileByPath(indexPath)
      // unsound
    };
  }
  throw new Error("Impossible");
}
function movableFile(file) {
  return file instanceof import_obsidian.TFile && isIndexFile(file) ? file.parent : file;
}
async function forceFile(file, app) {
  if (file.extension === "dir") {
    const fileParentPrefix = parentPrefix(file);
    const indexFile = await app.vault.create(
      fileParentPrefix + file.basename + ".md",
      ""
    );
    return indexFile;
  }
  return file;
}

// obsidian-reusables/src/ftags.ts
var import_obsidian2 = require("obsidian");

// obsidian-reusables/obsidian-typings/src/obsidian/implementations/TypeGuards/isFrontmatterLinkCache.ts
function isFrontmatterLinkCache(reference) {
  return !!reference.key;
}

// obsidian-reusables/src/ftags.ts
function getFileParentIndexes(file, app) {
  const parentIndexes = [];
  const data = app.metadataCache.getBacklinksForFile(file).data;
  for (const [fileWithLinkPath, refs] of data) {
    const fileWithLink = app.vault.getAbstractFileByPath(fileWithLinkPath);
    if (fileWithLink && fileWithLink instanceof import_obsidian2.TFile && refs.some(
      (r) => isFrontmatterLinkCache(r) && /^symlinks\.\d+$/.exec(r.key)
    ) && getFileIsTargetFileTagFilter(file, app)(fileWithLink)) {
      parentIndexes.push(fileWithLink);
    }
  }
  const directParent = isIndexFile(file) ? file.parent.parent : file.parent;
  parentIndexes.push(
    ...directParent.children.filter(isIndexFile).filter((v) => v instanceof import_obsidian2.TFile)
  );
  return parentIndexes;
}
var getFileIsTargetFileTagFilter = (targetFile, app) => {
  var _a;
  const movable = movableFile(targetFile);
  const trueParent = movable.parent;
  const indexFile = movable instanceof import_obsidian2.TFolder ? (_a = movable.children.find(isIndexFile)) != null ? _a : movable : movable;
  return (file) => {
    var _a2;
    const isDirectParent = isIndexFile(file) && file.parent === trueParent;
    if (isDirectParent)
      return true;
    const links = (_a2 = app.metadataCache.getCache(file.path)) == null ? void 0 : _a2.frontmatterLinks;
    return !!(links == null ? void 0 : links.some(
      (l) => l.key.startsWith("symlinks.") && app.metadataCache.getFirstLinkpathDest(l.link, file.path) === indexFile
    ));
  };
};

// node_modules/.pnpm/monkey-around@3.0.0/node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// obsidian-reusables/src/PluginWithSettings.ts
var import_obsidian3 = require("obsidian");
function PluginWithSettings(DEFAULT_SETTINGS2) {
  return class PluginWithSettings extends import_obsidian3.Plugin {
    constructor() {
      super(...arguments);
      this.settings = DEFAULT_SETTINGS2;
      this.uninstallers = [];
    }
    async loadSettings() {
      Object.assign(this.settings, await this.loadData());
    }
    async initSettings(SettingsTab) {
      await this.loadSettings();
      this.addSettingTab(new SettingsTab(this.app, this));
    }
    async saveSettings() {
      await this.saveData(this.settings);
    }
    registerPatch(obj, factories) {
      const uninstaller = around(
        obj,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        Object.fromEntries(
          Object.entries(
            factories
          ).map(([key, f]) => {
            return [
              key,
              (next) => f(next, this)
            ];
          })
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        )
      );
      this.uninstallers.push(uninstaller);
      return uninstaller;
    }
    uninstallPatches() {
      this.uninstallers.forEach((v) => {
        v();
      });
    }
    unload() {
      this.uninstallPatches();
    }
    getCheckCallbackWithValue(valueGetter, cb) {
      return (checking) => {
        const value = valueGetter();
        if (value && !checking)
          cb.apply(this, [value]);
        return !!value;
      };
    }
  };
}

// src/settings.ts
var import_obsidian5 = require("obsidian");

// obsidian-reusables/src/FolderSuggest.ts
var import_obsidian4 = require("obsidian");
var FolderSuggest = class extends import_obsidian4.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.close();
  }
  getSuggestions(query) {
    return this.app.vault.getAllFolders(true).filter((f) => f.path.includes(query));
  }
  renderSuggestion(value, el) {
    el.innerText = value.path;
  }
  onSelect(callback) {
    super.onSelect((value, evt) => {
      callback(value, evt);
      this.close();
      this.inputEl.blur();
    });
    return this;
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  inbox: "Uncategorized"
};
var MainPluginSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const options = Object.fromEntries(
      this.app.vault.getAllFolders().map((v) => [v.path, v.path])
    );
    options["/"] = "/";
    const setInbox = async (v) => {
      this.plugin.settings.inbox = v;
      await this.plugin.saveSettings();
    };
    new import_obsidian5.Setting(containerEl).setName("Inbox folder").setDesc("Folder where notes without explicit ftags are stored").addSearch((search) => {
      search.setValue(this.plugin.settings.inbox).onChange(setInbox);
      this.suggest = new FolderSuggest(this.app, search.inputEl);
      this.suggest.onSelect((v) => setInbox(v.path));
    });
  }
};

// src/main.ts
var allFilesFilter = (file) => file.extension === "md" || file.extension === "dir";
var CrosslinkAdvanced = class extends PluginWithSettings(
  DEFAULT_SETTINGS
) {
  constructor() {
    super(...arguments);
    this.renameAndKeepAsAlias = async (file) => {
      const currentName = file.getShortName();
      await this.app.fileManager.promptForFileRename(file);
      function isObj(v) {
        return typeof v === "object" && !!v;
      }
      function hasAliases(v) {
        return isObj(v) && ("aliases" in v && Array.isArray(v.aliases) || !("aliases" in v));
      }
      await this.app.fileManager.processFrontMatter(file, (v) => {
        if (!hasAliases(v))
          return;
        v.aliases || (v.aliases = []);
        v.aliases.push(currentName);
      });
    };
    this.getCurrentInboxedFileAndItsNonInboxTag = () => {
      var _a;
      const indexFile = this.app.workspace.getActiveFile();
      const currentFile = movableFile(indexFile);
      if (!currentFile || !indexFile)
        return;
      if (((_a = currentFile.parent) == null ? void 0 : _a.path) !== this.settings.inbox)
        return;
      const tags = this.app.vault.getFiles().filter(getFileIsTargetFileTagFilter(currentFile, this.app));
      const nonInboxTag = tags.find(
        (v) => movableFile(v).path !== this.settings.inbox
      );
      if (!nonInboxTag)
        return;
      return { nonInboxTag, indexFile, currentFile };
    };
    this.removeInboxTag = async ({
      indexFile,
      currentFile,
      nonInboxTag
    }) => {
      await this.removeFileSymlinkTo(indexFile, nonInboxTag);
      const { folder } = await forceFolder(nonInboxTag, this.app);
      await this.app.fileManager.renameFile(
        currentFile,
        folderPrefix(folder) + currentFile.name
      );
    };
    this.openAddFtagModal = (editedFile) => {
      const getDefaultPlaceholder = () => `Choose tags from all files for "${editedFile.basename}"`;
      const parents = new Set(getFileParentIndexes(editedFile, this.app));
      const allFilesExceptParents = (v) => allFilesFilter(v) && !parents.has(v) && v !== editedFile;
      const modal = new FileAndDirChooser(this.app, {
        filter: allFilesExceptParents,
        inbox: this.settings.inbox,
        onSelect: (file) => void this.addFtag(editedFile, file),
        customFileActions: [
          {
            icon: "tags",
            text: "Show this file's tags",
            cb: (_, selectedFile) => {
              modal.setPlaceholder(
                `Choose tags from "${selectedFile.basename}" for "${editedFile.basename}"`
              );
              modal.setFilter(
                getFileIsTargetFileTagFilter(
                  selectedFile,
                  this.app
                )
              );
              modal.clearQuery();
            }
          }
        ],
        customActions: [
          {
            icon: "rotate-ccw",
            text: "Reset filters and target file",
            cb: () => {
              modal.setPlaceholder(getDefaultPlaceholder());
              modal.setFilter(allFilesExceptParents);
            }
          }
        ]
      });
      modal.setPlaceholder(getDefaultPlaceholder());
      modal.open();
    };
    this.addFtag = async (file, ftag) => {
      var _a;
      if (((_a = movableFile(file).parent) == null ? void 0 : _a.path) === this.settings.inbox) {
        const movedFile = isIndexFile(file) ? file.parent : file;
        const { folder } = await forceFolder(ftag, this.app);
        await this.app.fileManager.renameFile(
          movedFile,
          `${folder.path}/${movedFile.name}`
        );
        new import_obsidian6.Notice(`Added ftag ${ftag.basename} by moving`);
      } else {
        const { index } = await forceFolder(ftag, this.app);
        const forcedIndex = await forceFile(index, this.app);
        await this.addFileSymlinkTo(file, forcedIndex);
        new import_obsidian6.Notice(`Added ftag ${ftag.basename} via link`);
      }
    };
    this.createNoteAsChild = async (currentFile) => {
      const { folder } = await forceFolder(currentFile, this.app);
      const note = await this.app.fileManager.createNewMarkdownFile(
        folder,
        "Untitled",
        ""
      );
      await this.app.workspace.openLinkText(note.path, "/", "tab", {
        active: true,
        eState: { rename: "all" }
      });
    };
  }
  async onload() {
    await this.initSettings(MainPluginSettingsTab);
    this.addCommand({
      id: "add-ftag",
      name: "Add ftag to the note",
      icon: "folder-symlink",
      checkCallback: this.getCheckCallbackWithValue(
        () => this.app.workspace.getActiveFile(),
        this.openAddFtagModal
      )
    });
    this.addCommand({
      id: "open-random-inbox-item",
      name: "Open random inbox item",
      icon: "dices",
      callback: this.openRandomInboxItem.bind(this)
    });
    this.addCommand({
      id: "rename-and-keep-as-alias",
      name: "Rename swapping for alias",
      icon: "edit",
      checkCallback: this.getCheckCallbackWithValue(
        () => this.app.workspace.getActiveFile(),
        this.renameAndKeepAsAlias
      )
    });
    this.addCommand({
      id: "remove-inbox-tag",
      name: "Remove inbox tag",
      icon: "combine",
      checkCallback: this.getCheckCallbackWithValue(
        this.getCurrentInboxedFileAndItsNonInboxTag,
        this.removeInboxTag
      )
    });
    this.addCommand({
      id: "create-note-as-child",
      name: "Create new note as child",
      icon: "corner-down-right",
      checkCallback: this.getCheckCallbackWithValue(
        () => this.app.workspace.getActiveFile(),
        this.createNoteAsChild
      )
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian6.TFile && file.extension === "md") {
          menu.addItem((item) => {
            item.setTitle("Rename swapping for alias").setIcon("edit").onClick(async () => {
              await this.renameAndKeepAsAlias(file);
            });
          });
        }
      })
    );
    this.addRibbonIcon(
      "dices",
      "Open random inbox item",
      this.openRandomInboxItem.bind(this)
    );
  }
  openRandomInboxItem() {
    const res = this.app.vault.getAbstractFileByPath(this.settings.inbox);
    const currentFile = this.app.workspace.getActiveFile();
    if (res instanceof import_obsidian6.TFolder) {
      const children = res.children.flatMap((child) => {
        if (child instanceof import_obsidian6.TFile && child.extension !== "dir")
          return child;
        if (child instanceof import_obsidian6.TFolder)
          return child.children.filter(isIndexFile).slice(0, 1);
        return [];
      });
      const chosen = children.filter((v) => v !== currentFile).shuffle()[0];
      if (chosen) {
        void this.app.workspace.openLinkText(chosen.path, "/");
      }
    } else if (!res) {
      new import_obsidian6.Notice(this.settings.inbox + " does not exist!");
    } else {
      new import_obsidian6.Notice(this.settings.inbox + " is a file!");
    }
  }
  async removeFileSymlinkTo(file, forcedIndex) {
    await this.app.fileManager.processFrontMatter(
      forcedIndex,
      (frontmatter) => {
        if (Array.isArray(frontmatter.symlinks)) {
          frontmatter.symlinks = frontmatter.symlinks.filter(
            (v) => this.app.metadataCache.getFirstLinkpathDest(
              v.slice(2, -2),
              forcedIndex.path
            ) !== file
          );
        }
      }
    );
  }
  async addFileSymlinkTo(file, forcedIndex) {
    const fileLink = this.app.fileManager.generateMarkdownLink(file, file.path).replace(/^!/, "");
    await this.app.fileManager.processFrontMatter(
      forcedIndex,
      (frontmatter) => {
        if (!frontmatter.symlinks) {
          frontmatter.symlinks = [fileLink];
        } else if (Array.isArray(frontmatter.symlinks)) {
          frontmatter.symlinks = [
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            ...frontmatter.symlinks.filter((v) => v !== fileLink),
            fileLink
          ];
        }
      }
    );
  }
};
var FileAndDirChooser = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, opts) {
    var _a, _b;
    super(app);
    this.inbox = opts.inbox;
    this.filter = opts.filter;
    this.onSelect = opts.onSelect;
    this.customFileActions = (_a = opts.customFileActions) != null ? _a : [];
    this.customActions = (_b = opts.customActions) != null ? _b : [];
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "to navigate" },
      {
        command: "shift \u21B5",
        purpose: "to create new note and use as new tag"
      },
      { command: "ctrl \u21B5", purpose: "to use selected file as new tag" },
      {
        command: "alt \u21B5",
        purpose: "to use selected file as new tag and clear"
      },
      { command: "\u21B5", purpose: "to use file as new tag and close" },
      { command: "esc", purpose: "to dismiss" }
    ]);
    this.inputEl.addEventListener("keydown", async (evt) => {
      if (evt.key === "Enter") {
        if ((evt.shiftKey || this.isWithoutShownSuggestions) && !this.isEmptyQuery) {
          await this.createNoteFromQuery({
            close: !evt.ctrlKey,
            clear: evt.altKey
          });
        } else if (evt.ctrlKey || evt.altKey) {
          this.selectHighlightedFile({ clear: evt.altKey });
        }
      }
    });
    const cta = this.inputEl.parentElement.querySelector(".prompt-input-cta");
    cta == null ? void 0 : cta.addClass("crosslink-advanced-custom-prompt-input-cta");
    const addButton = (icon, text, cb, phoneOnly) => {
      if (!import_obsidian6.Platform.isMobileApp && phoneOnly)
        return;
      const button = createEl("button", "clickable-icon", (e) => {
        (0, import_obsidian6.setIcon)(e, icon);
        e.setAttribute("aria-label", text);
        e.onclick = (e2) => {
          e2.stopPropagation();
          cb(e2);
        };
      });
      cta == null ? void 0 : cta.appendChild(button);
    };
    addButton("file-plus", "Create note with given name", (e) => {
      void this.createNoteFromQuery({
        close: !e.ctrlKey && !e.altKey,
        clear: e.altKey
      });
    });
    addButton(
      "file-stack",
      "Create note and clear input",
      () => {
        void this.createNoteFromQuery({
          close: false,
          clear: true
        });
      },
      true
    );
    for (const conf of this.customActions) {
      addButton(conf.icon, conf.text, (e) => {
        conf.cb(e, this.inputEl.value);
      });
    }
  }
  setFilter(filter) {
    this.filter = filter;
    this.recalculateSuggestions();
  }
  async createNoteFromQuery({
    close,
    clear
  }) {
    const newNote = await this.app.fileManager.createNewMarkdownFileFromLinktext(
      this.currentQuery,
      this.inbox
    );
    this.onSelect(newNote);
    if (close) {
      this.close();
    }
    if (clear) {
      this.clearQuery();
    }
  }
  selectHighlightedFile({ clear }) {
    const file = this.highlightedFile;
    if (file) {
      this.onSelect(file);
      if (clear) {
        this.clearQuery();
      }
    }
  }
  get highlightedFile() {
    if (this.hiddenChooser.selectedItem != null && this.hiddenChooser.values) {
      return this.hiddenChooser.values[this.hiddenChooser.selectedItem].item;
    }
    return void 0;
  }
  get isEmptyQuery() {
    return this.inputEl.value.trim().length === 0;
  }
  get isWithoutShownSuggestions() {
    return this.hiddenChooser.suggestions.length === 0;
  }
  get currentQuery() {
    return this.inputEl.value;
  }
  get hiddenChooser() {
    const chooser = this.chooser;
    return chooser;
  }
  clearQuery() {
    this.inputEl.value = "";
    this.recalculateSuggestions();
  }
  recalculateSuggestions() {
    this.inputEl.dispatchEvent(new InputEvent("input"));
  }
  getItems() {
    const lastOpenedFiles = this.app.workspace.recentFileTracker.lastOpenFiles;
    const set = new Set(lastOpenedFiles);
    const files = this.app.vault.getFiles();
    return files.filter(this.filter).sort((b, a) => {
      if (set.has(a.path) && !set.has(b.path))
        return 1;
      if (!set.has(a.path) && set.has(b.path))
        return -1;
      if (!set.has(a.path) && !set.has(b.path))
        return a.stat.mtime - b.stat.mtime;
      return -(lastOpenedFiles.indexOf(a.path) - lastOpenedFiles.indexOf(b.path));
    });
  }
  renderSuggestion(item, el) {
    import_obsidian6.FuzzySuggestModal.prototype.renderSuggestion.apply(this, [
      item,
      el
    ]);
    const content = el.createDiv("suggestion-content");
    const title = content.createDiv("suggestion-title");
    for (const child of Array.from(el.childNodes)) {
      if (child === content)
        continue;
      title.appendChild(child);
    }
    el.classList.add("mod-complex");
    const aux = el.createDiv("suggestion-aux");
    const createAuxButton = (icon, text, cb) => {
      const flair = aux.createSpan("suggestion-flair");
      flair.setAttribute("aria-label", text);
      flair.onclick = (evt) => {
        evt.stopPropagation();
        evt.preventDefault();
        cb(evt);
      };
      (0, import_obsidian6.setIcon)(flair, icon);
    };
    createAuxButton(
      "mouse-pointer-click",
      "Choose note without closing modal",
      () => {
        this.selectHighlightedFile({ clear: false });
      }
    );
    createAuxButton("search-slash", "Choose note and clear query", () => {
      this.selectHighlightedFile({ clear: true });
    });
    for (const opts of this.customFileActions) {
      createAuxButton(opts.icon, opts.text, (e) => {
        opts.cb(e, item.item);
      });
    }
  }
  getItemText(file) {
    var _a, _b, _c, _d, _e;
    const isIndex = file.basename === ((_a = file.parent) == null ? void 0 : _a.name);
    if (isIndex)
      return (_c = (_b = file.parent) == null ? void 0 : _b.path) != null ? _c : file.path;
    const aliases = (_e = (_d = this.app.metadataCache.getCache(file.path)) == null ? void 0 : _d.frontmatter) == null ? void 0 : _e["aliases"];
    if (Array.isArray(aliases))
      return file.path + "\n" + aliases.join(", ");
    return file.path;
  }
  onChooseItem(file) {
    this.onSelect(file);
  }
};

/* nosourcemap */