> [!info] Основная идея  
> Триггеры в PostgreSQL — это механизм, позволяющий автоматически выполнять действия при изменении данных в таблице. Они часто используются для валидации, логирования и обеспечения бизнес-правил на уровне базы данных.

## Краткий конспект

- Триггеры срабатывают при событиях INSERT, UPDATE, DELETE или TRUNCATE.
- Они могут запускаться до (`BEFORE`) или после (`AFTER`) изменения данных.
- Поддерживаются триггеры на уровне строки (`FOR EACH ROW`) и всего оператора (`FOR EACH STATEMENT`).
- Используются для автоматизации логики, аудита и защиты целостности данных.
- Требуют наличия триггерной функции, написанной на PL/pgSQL или другом языке.
- Неосторожное использование может повлиять на производительность.

## Что такое триггеры в PostgreSQL?

Триггеры — это объекты базы данных, которые автоматически исполняют заданную функцию при определённых событиях над таблицей. События могут быть следующими: вставка (INSERT), обновление (UPDATE), удаление (DELETE), а также очистка таблицы (TRUNCATE).

Триггер может быть выполнен:
- до выполнения основного действия (`BEFORE`)
- после него (`AFTER`)

Также триггеры могут быть определены:
- на каждую строку (`FOR EACH ROW`)
- на всю операцию (`FOR EACH STATEMENT`)

> [!example]
> Представим интернет-магазин. При каждом изменении цены товара мы хотим сохранять старое и новое значение в таблицу аудита. Это можно реализовать с помощью `AFTER UPDATE` триггера.

## Как работают триггеры

| Вид триггера       | Когда срабатывает           | Охват               |
|--------------------|-----------------------------|---------------------|
| `BEFORE`           | До изменения данных         | Может отменить действие |
| `AFTER`            | После изменения             | Используется для логирования |
| `FOR EACH ROW`     | На каждую затронутую строку | Подходит для тонкой логики |
| `FOR EACH STATEMENT` | Один раз на всю команду     | Используется реже |

Примеры событий:
- `INSERT`: добавление новых записей.
- `UPDATE`: изменение значений.
- `DELETE`: удаление строк.
- `TRUNCATE`: удаление всех данных таблицы.

> [!warning]
> `BEFORE`-триггеры могут изменять данные перед вставкой/обновлением, но в `AFTER`-триггерах это уже невозможно.

## Преимущества

- **Автоматизация** — триггеры упрощают реализацию повторяющейся логики.
- **Контроль целостности** — можно обеспечить правила, которые сложно выразить через `CHECK`.
- **Аудит и логирование** — позволяют отслеживать изменения без изменения клиентского кода.
- **Централизация бизнес-логики** — код не размазан по приложениям.

## Практическое применение

### 1. Soft-delete

```sql
CREATE FUNCTION soft_delete() RETURNS trigger AS $$
BEGIN
  NEW.deleted_at := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER mark_deleted
BEFORE DELETE ON products
FOR EACH ROW
EXECUTE FUNCTION soft_delete();
```

Вместо физического удаления мы помечаем запись как удалённую.

### 2. Логирование изменений цен

```sql
CREATE FUNCTION log_price_change() RETURNS trigger AS $$
BEGIN
  IF NEW.price IS DISTINCT FROM OLD.price THEN
    INSERT INTO price_audit(product_id, old_price, new_price, changed_at)
    VALUES (OLD.id, OLD.price, NEW.price, now());
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER track_price_update
AFTER UPDATE ON products
FOR EACH ROW
WHEN (OLD.price IS DISTINCT FROM NEW.price)
EXECUTE FUNCTION log_price_change();
```

> [!example]
> Это решение позволяет бизнесу отслеживать все изменения цен без необходимости писать дополнительный код на стороне приложения.

### 3. Валидация данных

```sql
CREATE FUNCTION check_price_positive() RETURNS trigger AS $$
BEGIN
  IF NEW.price < 0 THEN
    RAISE EXCEPTION 'Цена не может быть отрицательной';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_price
BEFORE INSERT OR UPDATE ON products
FOR EACH ROW
EXECUTE FUNCTION check_price_positive();
```

## Нюансы и подводные камни

- **Производительность** — чрезмерное использование `ROW`-триггеров на больших объемах данных может замедлить работу.
- **Рекурсия** — если триггер вызывает изменение, запускающее тот же триггер, возможна бесконечная рекурсия.
- **Безопасность** — для создания триггеров нужны соответствующие права (`TRIGGER`).
- **Отладка** — сложнее отлаживать поведение триггеров, чем обычный SQL-код.

>[!tip] Рекомендации
>
>- Используйте `WHEN`-условия, чтобы ограничить срабатывание триггера только при необходимости.
>- По возможности предпочитайте `STATEMENT`-триггеры `ROW`-триггерам.
>- Обрабатывайте ошибки в PL/pgSQL-функциях триггеров.
>- Храните важные бизнес-правила в коде триггера — это надёжнее, чем в клиентском приложении.

> [!faq]
>
**Q:** Можно ли в триггере изменить данные до вставки?  
**A:** Да, но только в `BEFORE`-триггере с помощью `NEW`.
>
**Q:** Могут ли триггеры вызываться при TRUNCATE?  
**A:** Да, но только `AFTER STATEMENT` триггеры.
>
**Q:** Как отключить триггеры временно?  
**A:** `ALTER TABLE mytable DISABLE TRIGGER ALL;` и включить обратно аналогично.
>
**Q:** Можно ли создать триггер только на UPDATE определённого поля?  
**A:** Да, с помощью `WHEN (OLD.field IS DISTINCT FROM NEW.field)`.

## Полезные ссылки

- https://www.postgresql.org/docs/current/sql-createtrigger.html  
- https://www.postgresql.org/docs/current/trigger-definition.html  
- https://www.cybertec-postgresql.com/en/trigger-best-practices-in-postgresql/  
- https://www.enterprisedb.com/blog/postgresql-triggers-explained  
- [[DDL]]  
- [[ACID]]  
