> [!info]  
> В Go массивы и срезы часто путают, но это разные сущности. Массивы — это фиксированной длины структуры, тогда как срезы являются удобной абстракцией над массивами, с динамическим управлением длиной и мощной семантикой.  
> Понимание срезов важно для эффективного управления памятью, избежания скрытых багов и написания производительного кода.

---

## Краткий конспект

- **Массивы** в Go имеют фиксированную длину и передаются по значению.
- **Срезы** являются «окном» в массив с длиной и capacity, передаются по ссылке.
- Slice — это структура с указателем, длиной и вместимостью (`slice header`).
- При работе с срезами легко допустить **aliasing** (два slice на одну память).
- `make` используется для создания срезов, `append` — для динамического расширения.
- `nil`-срез отличается от пустого, но ведёт себя предсказуемо.
- Производительность зависит от контроля над capacity и копированием.
- Следует понимать поведение при передаче slice в функции, чтобы избежать side-effects.

---

## Что такое массивы в Go

Массив в Go — это коллекция элементов **фиксированной длины**. Его тип включает в себя размер:

```go
var a [3]int = [3]int{1, 2, 3}
````

Массивы:

- нельзя изменять по длине;
    
- передаются по **значению** (копируются);
    
- редко используются напрямую — чаще опосредованно через срезы.
    

> [!example]
> 
> ```go
> func changeArray(arr [3]int) {
>     arr[0] = 99
> }
> ```

Этот код **не изменит** оригинальный массив, т.к. передаётся копия.

---

## Что такое срезы

**Срез (slice)** — это **динамическое представление** массива. Он не содержит данных, а указывает на массив, плюс хранит длину и capacity:

```go
s := []int{10, 20, 30}
```

Slice:

- может изменять длину с помощью `append`;
    
- передаётся по **ссылке** (структура копируется, но под ней лежит тот же массив);
    
- типичен в Go-коде: почти все функции работают с `[]T`, а не `[N]T`.
    

> [!tip]  
> Slice — это не массив, а дескриптор массива: он «смотрит» в массив, но не является им.

> [!faq]  
> **Q:** Почему массив `[3]int` и `[4]int` — это разные типы?  
> **A:** В Go размер входит в тип массива: `[3]int` ≠ `[4]int`.

---

## Внутреннее устройство slice

Slice в Go реализован через **slice header**, содержащий:

- **указатель** на первый элемент массива;
    
- **длину (len)**;
    
- **вместимость (cap)** — сколько ещё можно расширять до конца массива.
    

```go
type sliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
```

Slice не копирует данные массива — он ссылается на существующий массив. Несколько срезов могут ссылаться на один и тот же бэкенд.

> [!warning]  
> Увеличение длины через `append` может привести к **перевыделению** нового массива — старые ссылки устаревают.

---

## Типичные операции

### `make`

Создание среза с длиной и capacity:

```go
s := make([]int, 3, 5) // len=3, cap=5
```

### `append`

Добавление элементов, возможно — перевыделение:

```go
s := []int{1, 2}
s = append(s, 3, 4)
```

### `copy`

Копирует элементы между срезами:

```go
dst := make([]int, 3)
src := []int{10, 20, 30}
copy(dst, src)
```

### Операции среза

```go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4] // элементы 2, 3, 4
```

> [!tip]  
> `s[i:j]` создаёт slice с длиной `j - i`, но capacity = cap(arr) - i.

---

## Подводные камни и ошибки

### Aliasing

```go
s1 := []int{1, 2, 3}
s2 := s1
s2[0] = 99 // изменит s1 тоже
```

### `nil` vs пустой slice

```go
var s1 []int       // nil
s2 := []int{}      // пустой, но не nil
```

### Capacity-ловушки

```go
base := []int{1, 2, 3, 4}
sub := base[:2]
sub = append(sub, 99) // может изменить base!
```

> [!warning]  
> Не все `append` создают новый массив — если cap позволяет, может произойти shared write.

---

## Производительность и best-practice

- **Избегай лишнего `append`** — preallocate через `make`.
    
- **Наблюдай за cap(slice)** — для контроля перевыделений.
    
- **Измеряй**: не полагайся на предположения, используй `benchmarks`.
    
- **Избегай копий больших slice** — передавай по ссылке или работай с подмассивом.
    

> [!tip]  
> Используй `copy` вместо `append`, если нужно избежать aliasing или ускорить bulk-заполнение.

---

## Практические примеры использования

### 1. Инициализация и модификация

```go
s := make([]string, 0, 10)
s = append(s, "Go", "Rust", "C++")
```

### 2. Обработка среза в функции

```go
func double(s []int) {
    for i := range s {
        s[i] *= 2
    }
}
```

### 3. Безопасное расширение среза

```go
func safeAppend(s []int, val int) []int {
    return append(s, val)
}
```

### 4. Удаление элемента

```go
func removeAt(s []int, i int) []int {
    return append(s[:i], s[i+1:]...)
}
```

> [!example]  
> Удаление 3-го элемента из `[1,2,3,4]` → `append([1,2], [4]...)` = `[1,2,4]`

---

## Полезные ссылки

- [https://go.dev/blog/slices-intro](https://go.dev/blog/slices-intro)
    
- [https://go.dev/tour/moretypes/7](https://go.dev/tour/moretypes/7)
    
- [https://dev.to/dawkaka/go-arrays-and-slices-a-deep-dive-dp8](https://dev.to/dawkaka/go-arrays-and-slices-a-deep-dive-dp8)
    
- [https://golang.org/ref/spec#Slice_types](https://golang.org/ref/spec#Slice_types)
    
- [https://pkg.go.dev/builtin#copy](https://pkg.go.dev/builtin#copy)