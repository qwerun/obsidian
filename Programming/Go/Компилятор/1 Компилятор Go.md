## Основная идея

> [!info]  
> **Компилятор Go (gc) — «печь», которая превращает исходники в готовые программы**  
>   
> - **[[Сборка и запуск|go build]]** вызывает компилятор и собирает проект.  
> - **[[Сборка и запуск|go run]]** быстро компилирует и сразу запускает код.  
> - Флаги **`GOOS` / `GOARCH`** позволяют выпускать версии под Linux, Windows, macOS, ARM-платы — не меняя компьютер.  
>   
> Благодаря одному исполняемому файлу без внешних библиотек Go-приложения удобно деплоить в контейнеры, на серверы и даже на «умные» лампочки.

---

## Краткий конспект

> [!summary]  
> • **Скоростная сборка** — секунды даже на большом проекте.  
> • **Статический бинарь** — копируй и запускай без установки runtime.  
> • **Оптимизации «из коробки»** — inlining, удаление «мёртвого» кода, escape-анализ.  
> • **Кросс-платформа** — один компьютер, десятки целевых ОС/процессоров.

---

## Подробно

### Что такое компилятор Go?

*Компилятор* читает ваш `.go`-файл и пошагово делает из него программу:

1. **Чтение кода** — разбивает текст на слова-токены.  
2. **Построение «дерева» программы (AST)** — удобно проверять правила языка.  
3. **Проверка типов** — у строк нельзя вычитать числа и т.д.  
4. **Промежуточная форма SSA** — удобна для «умных» оптимизаций.  
5. **Оптимизации** — убирает лишние куски, раскладывает переменные по регистрам.  
6. **Генерация машинного кода** — инструкции процессора x86-64, ARM64, …  
7. **Линковка** — склеивает всё в один файл `exe` / `ELF` / `Mach-O`.

> [!tip]  
> Большую часть времени съедает не компилятор, а линковка. На SSD всё проходит заметно быстрее.

---

### Мини-пример

```go
// hello.go
package main

import "fmt"

func main() {
	fmt.Println("Hello, Go!")
}
````

```bash
# Компилируем под Linux ARM64, бинарь весит ~2 МБ
GOOS=linux GOARCH=arm64 go build -o hello
```

Скопируйте файл `hello` на Raspberry Pi — и он запустится без дополнительных библиотек.

---

### Преимущества на практике

| Где помогает                   | Почему это удобно                                                             |
| ------------------------------ | ----------------------------------------------------------------------------- |
| **Микросервисы**               | Один статичный бинарь → крошечный Docker-образ                                |
| **CLI-утилиты**                | Пользователь качает один файл, не думая о зависимостях.                       |

---

## Нюансы и подводные камни

> [!warning]
> 
> - **Большой проект → долгая линковка.** Попробуйте `-buildmode=shared` или держите кэш на SSD.
>     
> - **[[CGO]] ломает кросс-сборку.** Нужен C-компилятор для целевой платформы.
>     
> - **Бинарь «толстый».** Используйте `-ldflags "-s -w"` и `upx`, если важен размер.
>     
> - **PGO всё ещё экспериментален.** Неправильный профиль может даже замедлить программу.
>     

---

## Рекомендации и FAQ

> [!tip]  
> В больших репозиториях включайте _раздельную линковку_:  
> `go build -ldflags "-linkshared"` — ускоряет сборку, потому что общий код линковщик берёт из готовых библиотек.

> [!faq]  
> **Q:** Как собрать сразу под несколько платформ?  
> **A:** Скрипт в Makefile:
> 
> ```bash
> for GOOS in linux darwin windows; do
>   for GOARCH in amd64 arm64; do
>     go build -o build/$GOOS-$GOARCH/app \
>       GOOS=$GOOS GOARCH=$GOARCH ./cmd/app
>   done
> done
> ```
> 
> **Q:** Какие оптимизационные флаги самые популярные?  
> **A:**
> 
> ```bash
> # убрать отладочную информацию и символы
> go build -ldflags "-s -w" -trimpath .
> # показать, какие переменные «убегают» в heap
> go build -gcflags "all=-m" .
> ```

---

## Полезные ссылки

- [https://golang.org/doc/compile](https://golang.org/doc/compile)
    
- [https://blog.go.dev/](https://blog.go.dev/)
    
- Статья «Go SSA Form Explained»
    
- Доклад «Inside Go Linker» (GopherCon)