
На уровне ОС есть процессы, они делятся на потоки (треды)
Планировщик расрпеделяет потоки по виртуальным ядрам

Да, если говорить упрощённо, цепочка именно такая — **процессы → потоки → (планировщик) → логические ядра**.

Но полезно уточнить пару тонкостей:

1. **Что планируется**  
    Планировщик ядра работает не с «процессами» как контейнерами ресурсов, а с их **потоками** (kernel threads). У однопоточного процесса поток всего один, поэтому кажется, будто планируется сам процесс.
    
2. **Логические ядра ≠ потоки**
    
    - Логическое (виртуальное) ядро — это место, куда можно посадить _любой_ поток в данный момент времени.
        
    - Поток — это контекст выполнения: регистры, стек, счётчик инструкций и т. д.
    
3. **Создание vs. распределение**
    
    - Приложение (или стандартная библиотека через `pthread_create`, `std::thread` и т. п.) создаёт новые потоки внутри процесса.
        
    - Планировщик лишь решает, когда и на каком ядре запускать каждый из уже существующих потоков.


> [!tip] 
> На уровне ядра ОС есть процессы, процессы содержат потоки, а планировщик ОС распределяет эти потоки по доступным (логическим) ядрам.


> [!tip]
> Тредами управляет ОС, а горутинами гошный рантайм
>

---

Параллельность и конкурентность

![[Pasted image 20250804040848.png]]

---

GMP - Gorutin mashing processor

Mashing - примерно тред ОС

Processor - очередь горутин с дополнительным контекстом


У треда есть локальная очередь горутин, она работает по fifo, но имеет стек lifo
Локальная очередь работает следующим образом
горутина, которая попадает в очередь сначала попадает в lifo очередь, а потом вытесняется в fifo, поэтому если на одном треде будет несколько горутин, то большинстов из них будет вытеснено в fifo, а одна останется в lifo


![[Pasted image 20250804044547.png]]



Если одна из очередей пуста, то она у рандомной очереди ворует половину горутин себе это называется work stealing


Пример работы очереди

![[Pasted image 20250804045030.png]]

Системный вызов - ситуация, когда гошный рантайм отдает управление ОС, т.к. только она может его исполнить

Если в программе юзается системный вызов, то происходит следующее:
Создается новый тред в который отправляется горутина, залоченая системным вызовом, она там висит, пока ОС её не отпустит, а основная очередь не блочится

После того, как горутина отвиснет - она попадает в глобальную очередь

Есть правило работы с горутинами у процессора:

Бери готовые к работе горутины из локальной очереди
Если не нашел горутин в локальной очереди, воруй половину у другой
Если у соседа нет горутин, пробуй глянуть в глобальную очередь

 Также ввели magic number = 1/61 , то есть каждый 61 раз, когда процессор будет пытаться взять горутину, он будет принудительно брать её из глобальной очереди

---

Сеть 
Epol - в каждой ОС есть асинхронная имплементация для работы с сетью, по фату это пассивное ожидание ответа от сети

netpoller - абстракция в гошке, которая в linux навешена надо epol

То есть если по сети пошли в соседний сервис, мы не лочимся, а горутину, которая ожидает сетевого ответа отправляют в netpoller, когда ответ приходит, срабатывает триггер, горутина получает ответ -> залетает в глобальную очередь, после её заберут из глобальной очереди и она продолжит свое выполнение

---

Sysmon - системный мониторинг, не даёт работать горутине дольше 10 ms, также регулирует работу сборщика мусора


Итог
- Горутина управляется гошным рантаймом
- Вся магия менеджмента горутин скрыта за концепцией GMP
- Системные и сетевые вызовы обрабатываются отдельно







