> [!info] Основная идея  
> В Go 1.24 была полностью переработана реализация хеш-таблиц (`map`). До этого использовалась классическая bucket-based модель с цепочками overflow. С 1.24 введена **Swiss Table** — структура inspired by Abseil/JavaScript V8, которая значительно ускоряет доступ, особенно по памяти, за счёт control byte-таблиц и кеш-локальности. Это важное изменение, влияющее на производительность и подход к работе с мапами.

## Краткий конспект

- **Старая мапа** — использует bucket-и с цепочками переполнения и tophash для поиска.
    
- **Новая мапа (Swiss Table)** — группы по 8 слотов, control bytes, probing вместо цепочек.
    
- Улучшена **локальность данных** и **скорость доступа по ключу**.
    
- Итерация по map стала **быстрее и стабильнее**.
    
- **Удаления** теперь безопаснее при инкрементальной итерации.
    
- Для больших структур — **важна предварительная аллокация** через `make(map[T]V, size)`.
    

---

## Подробно

### Что изменилось в Go 1.24?

С переходом на Go 1.24 основная внутренняя структура `map` была заменена с bucket-based архитектуры на модель **Swiss Table**. Новая реализация вдохновлена C++ Abseil и JavaScript V8. Основные цели:

- Снизить **время доступа** и **аллокаций**;
    
- Уменьшить **число cache miss'ов**;
    
- Упростить GC-трейсинг.
    

> [!example] Пример кода
> 
> ```
> // До и после Go 1.24, API идентичен
> m := make(map[string]int, 1000)
> m["foo"] = 42
> fmt.Println(m["foo"])
> ```

Хотя внешний интерфейс map не изменился, поведение под капотом стало значительно эффективнее.

---

### Реализация `map` в Go ≤ 1.23

До версии 1.24 Go использовал модель хеш-таблицы с **бактами (buckets)**:

- Каждый бакет содержит 8 ячеек (slots) для пар ключ/значение.
    
- Если все слоты заняты и возникает новая коллизия — создаётся **overflow-бакет**.
    
- Lookup — последовательный пробег по бакету и overflow'ам.
    
- При расширении таблицы используется **incremental rehashing**.
    

#### Основные структуры:

```go
type hmap struct {
  buckets     unsafe.Pointer
  oldbuckets  unsafe.Pointer // при расширении
  count       int
  B           uint8 // логарифм количества бакетов
  ...
}
```

> [!warning]  
> Слишком много overflow-бакетов ухудшает производительность и приводит к cache miss'ам.

---

### Новая реализация `map` в Go 1.24 (Swiss Table)

С Go 1.24 `map` перешёл на модель, вдохновлённую **Swiss Table** (используется в `absl::flat_hash_map` от Google и Rust HashMap).

#### Ключевые изменения:

- **Контрольная метадата** (metadata byte per slot) — ускоряет поиск по хешу.
    
- **Пробег по 16 слотам** одновременно с SIMD-инструкциями.
    
- Вместо хранения ключей/значений по указателям — используется инлайн-структура с метаданными и смещениями.
    
- **Уменьшено количество аллокаций** и **повышена локальность**.

#### Пример (псевдокод):

```go
type bucket struct {
  metadata [16]uint8   // lower bits of hash
  keys     [16]keyType
  values   [16]valueType
}
```

> [!tip]  
> Метаданные используются для «предфильтрации» — сначала ищутся слоты с совпадающими bits, а потом сравниваются ключи.

---

### Сравнение реализаций

|Характеристика|Go ≤ 1.23|Go 1.24 (Swiss Table)|
|---|---|---|
|Структура|Buckets + overflow|Статичные группы по 16|
|Кол-во аллокаций|Больше|Меньше (~20–30%)|
|Производительность lookup|Умеренная|+15–40%|
|Устойчивость к коллизиям|Средняя|Выше (meta + fallback)|
|Cache locality|Низкая|Высокая|

> [!example]  
> В Go 1.24 производительность `map[int]int` улучшилась на 30–50% в синтетических тестах при больших объемах.

---

> [!warning] Подводные камни
> 
> - Поведение `map` остаётся **небезопасным в конкурентных операциях** без sync.Mutex.
>     
> - Удалённые элементы не сразу освобождают память.
>     
> - Не все старые эвристики (например, "размер должен быть степенью 2") теперь применимы.
>     

---

> [!tip] Рекомендации
> 
> - Используйте `make(map[T]V, n)` для избежания лишних аллокаций.
>     
> - Не рассчитывайте на порядок итерации — он по-прежнему не гарантирован.
>     
> - Для структур с большими ключами/значениями — профилируйте кеш-локальность.
>     
> - При вставке > 10^5 элементов предварительное выделение ёмкости даёт большой выигрыш.
>     

---

> [!faq] Часто задаваемые вопросы **Q:** Нужно ли переписывать код под новую мапу?  
> **A:** Нет — внешний API остался прежним, улучшения внутренние.
> 
> **Q:** Можно ли использовать мапу в нескольких горутинах без синхронизации?  
> **A:** Нет. Это приведёт к data race. Используйте `sync.Map` или `sync.Mutex`.
> 
> **Q:** Почему новая мапа быстрее?  
> **A:** Меньше cache miss, эффективный поиск по control bytes, компактная структура памяти.

---

## Полезные ссылки

- https://tip.golang.org/doc/go1.24
    
- https://go.dev/blog/swisstable
    
- https://www.bytesizego.com/blog/go-124-swiss-table-maps
    
- https://github.com/golang/go/issues/64520
    
- https://go.dev/doc/go-faq#map_order
