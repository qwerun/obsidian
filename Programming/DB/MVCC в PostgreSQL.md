> [!info] Основная идея  
> MVCC (Multi-Version Concurrency Control) — это механизм многоверсионного контроля параллелизма, позволяющий выполнять конкурентные запросы без блокировок на чтение. В PostgreSQL он обеспечивает согласованность данных и высокую производительность даже при множестве параллельных транзакций.

## Краткий конспект

* MVCC позволяет транзакциям видеть собственные "снимки" данных, не блокируя другие операции.
* В PostgreSQL реализация MVCC основана на системных столбцах `xmin` и `xmax`.
* Чтение происходит без блокировок, что повышает масштабируемость.
* Одним из недостатков является накопление "мертвых" строк (dead tuples), что требует VACUUM.
* Применяется для реализации изоляции транзакций и повышения производительности в OLTP-нагрузках.

---

## Подробно

### Что такое MVCC?

MVCC (Multi-Version Concurrency Control) — это стратегия управления параллельным доступом к данным, при которой изменения не блокируют чтения и наоборот. Каждая транзакция видит свою "версию" данных, соответствующую моменту начала транзакции. Это обеспечивает **изолированность** (`Isolation`) и **согласованность** (`Consistency`) — два из [[ACID||ACID транзакции]].

Вместо блокировок MVCC создаёт новые версии строк при изменениях. Транзакции читают только те версии, которые считаются "видимыми" согласно их снимку (`snapshot`). Таким образом, SELECT-запросы не блокируют UPDATE, а UPDATE не мешает другим SELECT.

PostgreSQL использует **MVCC по умолчанию** и реализует четыре уровня изоляции: Read Uncommitted, Read Committed (по умолчанию), Repeatable Read, Serializable.

---

### Как MVCC реализовано в PostgreSQL?

#### Системные столбцы: `xmin` и `xmax`

Каждая строка в таблице содержит скрытые системные поля:

- `xmin` — XID (Transaction ID), которая вставила строку.
- `xmax` — XID, которая удалит строку (если применимо).

#### Snapshots

Снимок (`snapshot`) фиксируется при начале транзакции и содержит:

- текущий `XID`,
- список активных транзакций,
- минимальный и максимальный диапазон `XID`.

Снимок определяет, какие строки «видны» на момент запроса.

#### VACUUM и Autovacuum

MVCC не удаляет физически устаревшие строки. VACUUM освобождает пространство от dead tuples. Автоматически это делает **Autovacuum**, но его параметры можно настраивать.

#### HOT-updates (Heap-Only Tuples)

Если обновление не затрагивает индексируемые поля, PostgreSQL выполняет **HOT-обновление**, не создавая новый индексный entry. Это уменьшает нагрузку на индексы.

> [!example] Пример  
> ```sql
> BEGIN;
> SELECT * FROM orders WHERE id = 42; -- читает старую версию
> UPDATE orders SET total = total + 10 WHERE id = 42;
> COMMIT;
> ```  
> Во время транзакции SELECT увидит старую версию строки. Новая строка появится в таблице, но будет видна другим транзакциям только после COMMIT. При этом старая версия останется, пока её не удалит VACUUM.

---

### Преимущества и ограничения

#### Преимущества

- ✅ **Неблокирующее чтение**: SELECT не блокирует UPDATE.
- ✅ **Масштабируемость**: можно обслуживать тысячи параллельных транзакций.
- ✅ **Гибкая изоляция**: реализация разных уровней ACID без накладных расходов на блокировки.
- ✅ **Оптимизация через HOT и Hint Bits**.

#### Ограничения

- ⚠️ **Нарастание bloat** — из-за dead tuples размер таблиц увеличивается.
- ⚠️ **Задержка освобождения места** — без VACUUM данные не удаляются физически.
- ⚠️ **Долгие транзакции** удерживают `xmin`, мешая очистке.
- ⚠️ **Автоматизация требует настройки** — неправильные параметры Autovacuum приводят к деградации производительности.

---

> [!warning] Подводные камни  
> * Неверные настройки Autovacuum могут не запускать очистку вовремя.

---

> [!tip] Рекомендации  
> * Используй `VACUUM (VERBOSE, ANALYZE)` регулярно для понимания, что происходит.  
> * Настрой `autovacuum_vacuum_cost_limit` под нагрузку сервера.  
> * Для OLTP-таблиц включи aggressive autovacuum (низкие пороги).  
> * Используй pg_stat_user_tables для мониторинга dead tuples.

---

> [!faq]  
> **Q:** Почему таблица растёт после DELETE?  
> **A:** Удалённые строки не исчезают сразу — они становятся dead tuples и остаются до VACUUM.  
>  
> **Q:** Как увидеть невидимые строки?  
> **A:** Используй расширение `pg_visibility` или модуль `pageinspect`. Например:  
> ```sql  
> SELECT * FROM pg_visibility('orders');  
> ```  
>  
> **Q:** Что делает autovacuum?  
> **A:** Автоматически запускает `VACUUM` и `ANALYZE`, чтобы поддерживать актуальность статистики и удалять ненужные версии строк.

---

## Полезные ссылки

* [PostgreSQL Docs: MVCC](https://www.postgresql.org/docs/current/mvcc.html)
* [PostgreSQL Docs: Vacuuming](https://www.postgresql.org/docs/current/routine-vacuuming.html)
* [Heikki Linnakangas blog: Understanding MVCC](https://heidi-postgres.blogspot.com)
