> [!info] **Основная идея**  
> **Атомарные операции** позволяют нескольким goroutine безопасно читать и изменять общее значение без тяжёлых блокировок. В Go 1.23 пакет `sync/atomic` получил новые типы-обёртки (`atomic.Int64`, `atomic.Pointer[T]`) и упрощённый API, благодаря чему писать высокопроизводительный конкурентный код стало проще и безопаснее.  

---

## Краткий конспект

- **1. Когда нужны атомики.** Ускоряют синхронизацию при мелких hot-полях, где `Mutex` даёт избыточный overhead.  
- **2. Базовый API.** Функции `AddInt64`, `LoadUint32`, `CompareAndSwapPointer` доступны с ранних версий Go.  
- **3. Типы-обёртки 1.19+.** `atomic.Int32`, `atomic.Bool`, `atomic.Pointer[T]` убирают `unsafe` и делают код чище.  
- **4. Мини-пример.** 100 горутин инкрементируют общий счётчик без гонок.  
- **5. Шаблон CAS-цикла.** `for { old := v.Load(); if v.CompareAndSwap(old, old+1) { break }}`.  
- **6. `atomic.Value`.** Для редких записей / частых чтений конфигурации (copy-on-write).  
- **7. Выравнивание на 32-битных CPU.** Атомики должны быть 64-битно выровнены, иначе undefined behaviour.  
- **8. False sharing.** Размещайте горячие атомики на отдельных cache-line или используйте padding.  
- **9. Отладка и профили.** Включайте `-race`, `go test -bench`, анализируйте `go tool pprof`.  
- **10. Best practices.** Атомики — не замена всем мьютексам; держите критичные секции минимальными, избегайте сложной бизнес-логики в CAS-циклах.  

---

## Подробно

### Что такое `sync/atomic` и когда применять вместо мьютексов или каналов

`sync/atomic` предоставляет **атомарные (неделимые)** операции над числами, указателями и бульскими флагами. Каждая такая операция выполняется как одна CPU-инструкция (или пара инструкций с память-барьером), поэтому:

* **Меньше latency.** Нет переключения контекстов, парка/анпарка горутин.  
* **Без ворсинга scheduler’а.** Не блокируют рантайм, поэтому GOMAXPROCS CPU используются эффективнее.  

Используйте атомики, если:

1. Критичная секция логически ограничена крошечным числом переменных.  
2. Вся работа укладывается в одно арифметическое действие (инкремент, флаг завершения, pointer swap).  
3. Чтения сильно доминируют над записями (например, глобальный конфиг, счётчики метрик).  

Не используйте их там, где нужна **хранить сложные структуры** или требуется **гарантия взаимного исключения** для нескольких полей одновременно — у `Mutex` это проще и надёжнее.

---

### Базовые функции (`AddT`, `LoadT`, …) до Go 1.19

До появления обёрток API состоял из свободных функций:

```go
var counter int64
atomic.AddInt64(&counter, 1)        // ++counter
v := atomic.LoadInt64(&counter)     // чтение
atomic.StoreInt64(&counter, 0)      // сброс
ok := atomic.CompareAndSwapInt64(&counter, exp, new) // CAS
````

Минусы подхода:

- **Ошибка типов:** легко передать не тот указатель.
    
- **Обилие `&` и `*`.** Читаемость падает.
    
- **Нельзя сделать дженерик-указатель.**
    

---

### Обёртки из Go 1.19+ (`atomic.Int32`, `atomic.Pointer[T]`, …)

Go 1.19 принес пакет-обёртку:

```go
var c atomic.Int64
c.Add(1)
current := c.Load()
```

Плюсы:

- Нет `unsafe`.
    
- Методы внутри inlined, производительность идентична «старым» функциям.
    
- Дженерики: `atomic.Pointer[*MyStruct]` хранит ссылку на любой тип T.
    

Go 1.23 дополнительно оптимизировал эти методы (inlining + сокращённые барьеры), снизив накладные расходы на ~8 % в микротестах.

---

### Мини-пример: 100 горутин инкрементируют `atomic.Int32`

```go
// go run main.go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var counter atomic.Int32
	var wg sync.WaitGroup

	const workers = 100
	wg.Add(workers)

	for i := 0; i < workers; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < 1_000; j++ {
				counter.Add(1)
			}
		}()
	}

	wg.Wait()
	fmt.Println("final:", counter.Load()) // ожидаем 100_000
}
```

> [!example]  
> **Ожидаемый вывод:**
> 
> ```
> final: 100000
> ```

Код запускается на Go 1.23 без флагов и не вызывает `-race`-ошибок.

---

### Шаблон Compare-and-Swap (CAS) с циклом `for {}`

```go
func increment(v *atomic.Int64) {
	for {
		old := v.Load()
		if v.CompareAndSwap(old, old+1) {
			return
		}
	}
}
```

> [!tip]  
> Всегда добавляйте **back-off** (например, `runtime.Gosched()` или `time.Sleep(0)`) при высокой контеншен-нагрузке — это снижает горячее вращение (spin) и даёт шанс другим goroutine захватить CPU.

---

### Использование `atomic.Value`

`Value` хранит **одно интерфейсное значение** и обеспечивает lock-free доступ с правилами «сорт-of RCU»:

```go
var cfg atomic.Value           // хранит *Config
cfg.Store(loadConfig("prod"))  // редкая запись

func handle() {
	c := cfg.Load().(*Config)   // частое чтение
	// …
}
```

Плюсы `Value`:

- Одновременная загрузка безопасна.
    
- Набор полей может меняться; главное — все записи должны быть _одного_ конкретного типа.
    

> [!warning]  
> Первая запись (`Store`) должна происходить **до** первого `Load`; иначе произойдёт `panic("atomic: Value.Load of empty Value")`.

---

### Выравнивание на 32-битных платформах

На ARMv7, 386 и других 32-битных архитектурах **64-битные** атомики (`Int64`, `Uint64`) должны находиться в **адресе, выровненном по 8 байт**. В противном случае Go кинет паническое сообщение «misaligned 64-bit atomic operation».

Решения:

1. Объявляйте атомик **первым полем** структуры.
    
2. Используйте build-тег `//go:align64`.
    
3. На практике — компилируйте под 64-бит, если нет обязательной поддержки embedded.
    

---

### Проблема false sharing и советы по оптимизации

False sharing возникает, когда два независимых атомика делят один **кэш-лайн** (64 байта на x86-64). Каждая запись инвалидирует кэш соседа → каскадные слоумдауны.

```go
type counters struct {
    read atomic.Int64
    _    [7]int64 // padding 56 B
    write atomic.Int64
}
```

> [!tip]  
> В Go 1.23 есть экспериментальный pragma `//go:breadslice` (пока в компиляторе dev-branch), автоматически добавляющая padding к hot-полям — следите за issue #67903.

---

### Практические рекомендации

1. **Минимизируйте атомики.** Храните только горячие флаги/счётчики; остальное — под мьютексом.
    
2. **Профилируйте.** `go test -bench` + `-benchmem`, `pprof` CPU/alloc покажут, окупаются ли атомики.
    
3. **Ставьте `-race` на CI.** Он не ловит ABA-проблему, но находит неправильную смешанную синхронизацию (atomic + non-atomic).
    
4. **Склейте операции.** Если нужно изменить _несколько_ атомиков, объедините их в структуру и обновляйте через `atomic.Pointer`.
    
5. **Документируйте контракт.** Напишите комментарий, какая переменная «ведущая», кто читает/пишет, какой порядок операций.
    

---

> [!faq]  
> **Q:** Можно ли использовать атомарный счётчик поверх `map`?  
> **A:** Да: для статистики (`map[string]*atomic.Int64`) — главное, чтобы сами указатели на счётчики не менялись после инициализации.
> 
> **Q:** Почему мой код с атомиками медленнее `Mutex`?  
> **A:** При высокой контеншен-нагрузке CAS начинает проигрывать из-за бесконечных прерываний; попробуйте `sync.Mutex` или разделите шардирование.
> 
> **Q:** Как отложить инициализацию большого объекта, не загораживая все goroutine?  
> **A:** Используйте двойную проверку `v.Load()` + `CompareAndSwap(nil, newObj)` внутри CAS-цикла, либо `sync.Once`.

---

## Полезные ссылки

- [RUTUBE: Изучаем Golang. Урок №25](https://rutube.ru/video/d86549d394150f8e62675d0799002292/)
    
- [Coding Explorations: sync/atomic](https://www.codingexplorations.com/blog/understanding-and-using-the-syncatomic-package-in-go)
    
- [Go 101: Atomic Operations](https://go101.org/article/concurrent-atomic-operation.html)
    
- Go 1.23 Release Notes — [https://tip.golang.org/doc/go1.23](https://tip.golang.org/doc/go1.23)
    
- Package `sync/atomic` docs — [https://pkg.go.dev/sync/atomic](https://pkg.go.dev/sync/atomic)