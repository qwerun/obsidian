> [!info] Основная идея  
> **Хеш‑таблица** даёт мгновенный доступ к значению по ключу, **множество** гарантирует уникальность элементов, **стек** придерживается принципа LIFO (кто вошёл последним, выйдет первым), а **очередь** — FIFO (кто пришёл первым, уйдёт первым). 

---

## Краткий конспект

- **Практическое применение** — кеши, обходы графов (BFS/DFS), системы очередей
    
- **Связанные концепции** — [[Алгоритмы поиска]], [[Сложность алгоритмов]]
    

---

### Что такое хеш‑таблица?

Хеш‑таблица (hash table) — это, по сути, _ассоциативный массив_. Её основа — фиксированный массив ячеек и **хеш‑функция**, превращающая произвольный ключ (строку, число, объект) в индекс этого массива.

_Средняя сложность_ основных операций — **O(1)**, то есть время практически не растёт с объёмом данных.

#### Коллизии

Когда два ключа дают одинаковый индекс — это **коллизия**. Существует два популярных способа борьбы:

|Метод|Суть|Минусы|
|---|---|---|
|**Separate chaining**|В каждой ячейке хранится связанный список (или динамический массив) элементов с одинаковым индексом.|Память на доп. структуры|
|**Open addressing**|При столкновении ищется следующая свободная ячейка (`(index + 1) mod size`, квадр. пробирование, двойной хеш).|Производительность падает при высокой заполненности|

```text
function get(table, key):
    index ← hash(key) mod size
    while table[index] is occupied:
        if table[index].key = key:
            return table[index].value
        index ← (index + 1) mod size
    return NOT_FOUND
```

> [!tip]  
> Правило большого пальца: держите **load factor** (отношение занятых ячеек к размеру массива) ≈ 0.65. При превышении рехешируйте таблицу: создайте новый больший массив и перевставьте элементы.

---

### Что такое set?

**Set** — контейнер, в котором элемент может встречаться _только один раз_. За кулисами оно чаще всего реализуется:



---

### Что такое стек?

**Стек (stack)** — это структура LIFO: _последним зашёл — первым вышел_. Представьте стопку тарелок: снимаем верхнюю, пока не доберёмся до нужной.

|Операция|Описание|
|---|---|
|`push(x)`|положить элемент на верх|
|`pop()`|снять и вернуть верхний|
|`peek()`|посмотреть верхний, не удаляя|


> [!warning]  
> Глубокая рекурсия может привести к _stack overflow_ — превышению доступного объёма стека.

---

### Что такое очередь?

**Очередь (queue)** — модель FIFO: как очередь в магазине.

|Операция|Описание|
|---|---|
|`enqueue(x)`|добавить в хвост|
|`dequeue()`|удалить из головы|
|`front()`|посмотреть первый|

**Вариации**

- **Deque**: операции с двух концов.
    
- **Приоритетная очередь**: элемент с наивысшим приоритетом (минимальным ключом в heap) выходит первым.
    

**Применения**

- Алгоритм **BFS** (обход в ширину).
    
- **Сетевые буферы**: пакеты данных обрабатываются по порядку.
    

---

### Преимущества

1. **Скорость** — близкая к O(1) у хеш‑таблиц, стеков и очередей.
    
2. **Экономия памяти** — минимальные служебные данные при правильных настройках.
    
3. **Простота алгоритмов** — отражают естественную модель задачи (кеш, очередь печати, возврат назад).
    
4. **Композиция** — их легко комбинировать: например, очередь + приоритет → приоритетная очередь.
    

---

### Практическое применение

- **Кеши, словари конфигураций** — хеш‑таблица.
    
- **Поиск кратчайшего пути** (BFS) — очередь.
    
- **DFS, парсеры выражений** — стек.
    
- **Списки уникальных тегов или пользователей** — множество.
    
- **Системы логирования** — кольцевые очереди для постоянного потока сообщений.
    

> [!tip]  
> Сочетайте структуры: LRU‑кеш (Least Recently Used) — это хеш‑таблица + двусвязный список/deque.

---

### Нюансы и подводные камни

> [!warning] Распространённые проблемы
> 
> - **Плохая хеш‑функция** → концентрируются коллизии → операции O(n).
>     
> - **resize** хеш‑таблицы стоит O(n); планируйте ёмкость заранее.
>     
> - **Переполнение стека** при глубокой рекурсии.
>     
> - **Блокировки**: очереди/стэки в многопоточной среде требуют синхронизации или lock‑free алгоритмов.
>     

---

### Рекомендации и FAQ

> [!tip] Как выбрать структуру?
> 
> - Нужен быстрый поиск по ключу → **хеш‑таблица**.
>     
> - Нужно хранить уникальные элементы без порядка → **множество**.
>     
> - Требуется LIFO‑логика (Undo, парсинг) → **стек**.
>     
> - FIFO‑процессинг (очередь задач) → **очередь/deque**.
>     
> 
> [!faq]  
> **Q:** Почему время вставки в хеш‑таблицу внезапно выросло?  
> **A:** Скорее всего, load factor превысил порог, и таблица рехешируется. Увеличьте размер заранее.
> 
> **Q:** Можно ли сделать стек/очередь на одном динамическом массиве?  
> **A:** Да. Для стека достаточно `append`/`pop`; для очереди — «кольцевой буфер» с двумя индексами.
> 
> **Q:** Чем приоритетная очередь отличается от обычной?  
> **A:** В приоритетной порядок выдачи задаётся весом (часто min‑heap), а не временем поступления.

---

## Полезные ссылки

- Robert Sedgewick, Kevin Wayne — _Algorithms_
    
- Cormen, Leiserson, Rivest, Stein — _Introduction to Algorithms_
    
- Wikipedia: [Hash table](https://en.wikipedia.org/wiki/Hash_table) • [Set](https://en.wikipedia.org/wiki/Set_\(abstract_data_type\)) • [Stack](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)) • [Queue](https://en.wikipedia.org/wiki/Queue_\(abstract_data_type\))