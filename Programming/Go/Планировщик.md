> [!info] **Основная идея**  
> Вы пользуетесь горутинами и каналами каждый день, но за ними скрыт мощный рантайм Go. Понимание его внутренней кухни — ключ к оптимизации производительности, уменьшению пауз GC и устранению «мистических» латентностей.

---

## Краткий конспект

- **Рантайм Go** — это отдельная мини-ОС: планировщик, сборщик мусора, сигналы, трассировки.  
- **P-M-G-модель** делит работу между процессорами (P), потоками ОС (M) и горутинами (G).  
- **Горутины** стартуют с ~2 КБ стека, который растёт и перемещается прозрачно.  
- **Планировщик** сочетает кооперативную и мягкую вытесняющую многозадачность через safepoints.  
- **GC** (маркировка-сведение + concurrent sweep) в Go 1.24 держит паузы <1 мс на 100 ГБ хипа.  
- Знание рантайма помогает: находить deadlock-и, снижать tail-latency, настраивать pprof/trace.  

---

## Подробно

### Планировщик: сердце рантайма

Go-рантайм реализует собственный планировщик поверх потоков ОС.  
В актуальной версии **Go 1.24** он основан на **P-M-G-модели**:

| Сущность | Роль | Ограничение |
|----------|------|-------------|
| **G** (goroutine) | Лёгкая «зелёная» задача | миллионы на процесс |
| **M** (machine)   | Поток ОС, выполняющий G   | ограничен ядрами и настройкой `runtime.GOMAXPROCS` |
| **P** (processor) | Логический процессор: хранит run-queue, локальный кеш, random seed | количество = `GOMAXPROCS` |

> [!example]
> ```go
> fmt.Println(runtime.GOMAXPROCS(0)) // покажет число P
> ```

1. **Dispatcher** закрепляет P за M и выдаёт ему G из локальной очереди.  
2. Если очередь пуста — воркует G у другого P (work-stealing).  
3. При системных вызовах M паркуется, а G переводится в список *waiting*.  

> [!tip]  
> Чтобы вручную уступить планировщику, вызывайте `runtime.Gosched()` или культивируйте каналы/блокирующие операции.

### Горутины и стек: «эластичный» подход

- **Начальный стек** ≈ 2 КБ (вместо 1 МБ у потока POSIX).  
- При переполнении выполняется **split stack**: новый больший сегмент аллоцируется, данные копируются.  
- В Go ≥ 1.22 перемещение стека выполняется в момент обращения к защитной странице, минимизируя оверхед.

> [!warning]  
> Большие массивы на стеке → частые перемещения. Храните крупные буферы в хипе (`make([]byte, ...)`), а не как локальные массивы.

### Кооператив + вытесняющая мультизадачность

Исторически Go полагался на кооперативный вызов проверок (точки прерывания в обращениях к массивам, каналам, аллокаторам). В Go 1.14 добавили **asynchronous preemption** — М может послать сигнал другому потоку, чтобы установить флаг и прервать долгоработающую G (спинящий цикл, CGO).  

- Safepoint — место, где стек консистентен (обращение к стеку, вызов функции).  
- Не пугайтесь: это «мягкая» вытесняющая модель; гонку с планировщиком всё равно невозможно устроить.

### Сборщик мусора: пазл latency vs throughput

GC Go — **mark-sweep-compact**, полностью конкурентный с многими пасами инкрементальной маркировки.

| Релиз | Максимальная stop-the-world пауза | Основные улучшения |
|-------|-----------------------------------|---------------------|
| 1.18  | ~2 мс на 10 ГБ                    | `assistG` бюджет + pacer |
| 1.22  | ≤1 мс / 25 ГБ                     | оптимизация tinyalloc |
| 1.24  | ≤1 мс / 100 ГБ                    | улучшена точность, сжатие bitmap |

> [!example] *Профилируем GC*  
> ```go
> go run main.go
> go tool pprof -http=:6060 http://localhost:6060/debug/pprof/heap
> ```

> [!tip]  
> Избегайте краткоживущих больших объектов. Используйте `sync.Pool` и re-use буферов.

### Жизненный цикл программы

1. **`rt0_go`** — низкоуровневый старт: создаёт стек, настраивает TLS.  
2. **`runtime.main`** — инициализация GC, сетап goroutine 0.  
3. **`main.main`** — ваша точка входа, запускается как G=1.  
4. Завершение всех пользовательских goroutine ведёт к вызову **`goexit`**.

> [!example]
> ```go
> // go run -gcflags=-m=2 main.go
> // Посмотреть inlining + escape анализ
> ```

### Каналы: синхронизация и коммуникация

Внутри канал — структура `hchan` с кольцевым буфером, счётчиками `sendx/recvx` и списками `sudog` (отложенные операции).  

- **Отправка/получение** проверяет готовность; иначе горутина паркуется.  
- Буфер ≥ 1 превращает канал в MPMC-очередь.

> [!warning]  
> Пустой неблокирующий `select {}` никогда не уступит планировщику и сожрёт ядро.

### Практическая польза

- **Понимание стека** — облегчает чтение pprof (почему 100 МБ стека?).  
- **Scheduler trace** (`go tool trace`) позволяет выловить starvation.  
- **GC-knobs** (`GOGC`, `GOMEMLIMIT`) управляют паузами и хипом.  
- Архитектура: знание гранулярности переключений помогает решить, канал или mutex.

---

### Итоговые выжимки

- Планировщик ≠ поток ОС; вы управляете количеством P через `GOMAXPROCS`.  
- Каждая горутина лёгкая, но миллионы горутин ≠ бесплатно: хип + поиск run-queue.  
- GC становится быстрее, но блокирующие CGO-вызовы всё ещё зло.  
- Лейзи-стек перемещается прозрачно; избегайте статичных 1 МБ массивов.  
- Тонкая настройка параметров рантайма — последний шаг после профилирования.

---

> [!faq]  
> **Q:** Нужно ли всегда фиксировать `GOMAXPROCS = runtime.NumCPU()`?  
> **A:** Обычно да, но при высоком contention и многочисленных сетевых прерываниях уменьшение P может снизить L3-miss-rate.  
> 
> **Q:** Почему мои горутины «зависают» при heavy syscalls?  
> **A:** M, выполняющий G, уходит в системный вызов; без свободного P планировщик не переназначит другие G. Используйте `runtime.LockOSThread` осторожно.  
> 
> **Q:** Как узнать, сколько времени горутина провела в GC-assist?  
> **A:** `go tool trace` → View → Goroutines → выбрать G и посмотреть «GC (assist)».  
> 
> **Q:** Есть ли pre-emptive scheduling полностью?  
> **A:** В Go 1.14+ реализована мягкая вытесняющая модель: M прерывает G через async preemption, но только в safepoint.  
> 
> **Q:** Зачем читать код рантайма?  
> **A:** Чтобы понять, почему пулы объектов ускоряют GC, как работает `select`, и где закончится стек.

---

## Полезные ссылки

- https://go.dev/doc/runtime  
- https://go.dev/blog/pprof  
- https://go.dev/blog/scheduling  
- https://go.dev/blog/gc-guide  
- https://videohighlight.com/v/rloqQY9CT8I — «Go под капотом» (Сергеев А.)  