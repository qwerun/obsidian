> [!info] **Основная идея**  
> В многопоточном программировании на Go примитивы синхронизации из пакета `sync` — такие как **Mutex**, **WaitGroup** и **RWMutex** — позволяют безопасно управлять доступом к разделяемым данным.  
> Каждый из них служит своей цели: `Mutex` для взаимного исключения, `WaitGroup` для ожидания завершения группы горутин, а `RWMutex` оптимизирует работу при частом чтении и редком изменении.

## Краткий конспект
- **Mutex** — обеспечивает эксклюзивный доступ к разделяемым данным.  
- **WaitGroup** — позволяет ждать завершения набора параллельных задач.  
- **RWMutex** — разделяет блокировки на чтение и запись, полезно при высокой конкуренции на чтение.  
- Все примитивы находятся в пакете `sync` и требуют осторожного обращения.  
- Неверное использование может привести к _deadlock_, _data race_ или панике.

---

## Подробно

### Что такое Mutex?

`sync.Mutex` — базовый примитив для синхронизации горутин, обеспечивающий взаимное исключение. Он позволяет только одной горутине выполнять код, заключённый между вызовами `Lock()` и `Unlock()`.

> [!example]  
> ```go
> package main
> 
> import (
> 	"fmt"
> 	"sync"
> )
> 
> type Counter struct {
> 	mu sync.Mutex
> 	v  int
> }
> 
> func (c *Counter) Inc() {
> 	c.mu.Lock()
> 	defer c.mu.Unlock()
> 	c.v++
> }
> 
> func (c *Counter) Value() int {
> 	c.mu.Lock()
> 	defer c.mu.Unlock()
> 	return c.v
> }
> 
> func main() {
> 	var wg sync.WaitGroup
> 	c := Counter{}
> 
> 	for i := 0; i < 100; i++ {
> 		wg.Add(1)
> 		go func() {
> 			c.Inc()
> 			wg.Done()
> 		}()
> 	}
> 	wg.Wait()
> 	fmt.Println("Final value:", c.Value())
> }
> ```

> [!tip]  
> `defer c.mu.Unlock()` — надёжный способ гарантировать разблокировку даже при панике.

---

### WaitGroup — «барьер» для горутин

`sync.WaitGroup` нужен, когда вы запускаете множество горутин и хотите дождаться их завершения. Он инкрементирует счётчик вызовом `Add(n)`, уменьшает его `Done()` и блокирует выполнение до нуля через `Wait()`.

> [!example]  
> ```go
> package main
> 
> import (
> 	"fmt"
> 	"sync"
> )
> 
> func worker(id int, wg *sync.WaitGroup) {
> 	defer wg.Done()
> 	fmt.Printf("Worker %d done\n", id)
> }
> 
> func main() {
> 	var wg sync.WaitGroup
> 	for i := 1; i <= 5; i++ {
> 		wg.Add(1)
> 		go worker(i, &wg)
> 	}
> 	wg.Wait()
> 	fmt.Println("All workers finished")
> }
> ```

> [!warning] **Подводные камни**  
> Вызов `wg.Add()` должен происходить **до** запуска горутин, иначе возможна гонка между запуском и завершением.

---

### RWMutex — когда много читателей, мало писателей

`sync.RWMutex` расширяет обычный `Mutex`, добавляя возможность разделения блокировок:

- `RLock()` / `RUnlock()` — для чтения;  
- `Lock()` / `Unlock()` — для записи.

Чтение может выполняться одновременно из нескольких горутин, пока ни одна не пишет.

> [!example]  
> ```go
> package main
> 
> import (
> 	"fmt"
> 	"sync"
> )
> 
> type SafeMap struct {
> 	mu sync.RWMutex
> 	m  map[string]string
> }
> 
> func (s *SafeMap) Get(key string) string {
> 	s.mu.RLock()
> 	defer s.mu.RUnlock()
> 	return s.m[key]
> }
> 
> func (s *SafeMap) Set(key, value string) {
> 	s.mu.Lock()
> 	defer s.mu.Unlock()
> 	s.m[key] = value
> }
> 
> func main() {
> 	s := SafeMap{m: make(map[string]string)}
> 	s.Set("lang", "Go")
> 	fmt.Println(s.Get("lang"))
> }
> ```

> [!tip]  
> `RWMutex` идеален для кэшей, конфигураций и read-heavy сценариев. Но при большом числе записей выигрыша может не быть.

> [!warning] **Подводные камни**  
> - Забытый `Unlock()` приведёт к зависанию.  
> - Нельзя копировать значения `Mutex`/`WaitGroup`/`RWMutex` — только по указателю.  
> - Вложенные блокировки без понимания порядка вызовов — прямой путь к deadlock.  
> - Не используйте `defer` в tight loop — из-за лишних аллокаций.

---

> [!tip] **Рекомендации**  
> - Используйте `RWMutex`, только если профилирование показывает преимущество.  
> - Придерживайтесь простого порядка блокировок — это снижает шанс взаимной блокировки.  
> - Для простого ожидания завершения — предпочтительнее `WaitGroup`, а не каналы.  
> - При необходимости отмены используйте `[[context.Context]]`.

---

> [!faq] **Часто задаваемые вопросы**  
> **Q:** Почему нельзя копировать `sync.Mutex`?  
> **A:** Потому что копирование нарушает внутреннее состояние — это приводит к гонкам или панике.  
>  
> **Q:** Когда `RWMutex` хуже обычного `Mutex`?  
> **A:** При большом числе конкурентных записей — переключение режимов блокировки даёт оверхед.  
>  
> **Q:** Чем `WaitGroup` отличается от канала?  
> **A:** `WaitGroup` предназначен именно для подсчёта завершившихся задач, каналы — для передачи данных.  
>  
> **Q:** Можно ли вложить `WaitGroup` в структуру?  
> **A:** Да, но обращаться к нему нужно аккуратно — не пересоздавать между `Add`/`Wait`.

