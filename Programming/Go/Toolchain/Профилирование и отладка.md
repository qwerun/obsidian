## Основная идея

> [!info]
> Инструменты **`go tool pprof`**, **`go tool trace`**, **`go tool cover`** и **`go debug`** формируют встроенный стек диагностики Go.  
> - **`pprof`** — снимает и визуализирует профили CPU/heap.  
> - **`trace`** — пишет подробные события runtime и отображает их в браузере.  
> - **`cover`** — строит отчёты покрытия кода тестами.  
> - **`go debug`** — интерактивная отладка в терминале без сторонних IDE.  
> Совместно утилиты дают цикл «снять профиль → найти узкое место → оптимизировать → проверить» — от микросервисов до CLI-скриптов.

---

## Краткий конспект

* **Стек** — `pprof`, `trace`, `cover`, `go debug`.  
* **Плюсы** — точные профили, наглядные трейсы, метрика покрытия, live-отладка.  
* **Применение** — опт-микросервиса, поиск утечек памяти, отчёты CI.  

---

## Подробно

### Что такое профилирование и отладка в Go?

Пакеты `runtime/pprof` и `runtime/trace` пишут бинарные профили и трейсы, которые анализируются одноимёнными инструментами `go tool pprof/trace`. Для покрытия компилятор генерирует счётчики (`-coverprofile`), а `go debug` пользуется тем же runtime-API, что Delve, но идёт вместе с toolchain.

1. Снять профиль или трассу.  
2. Найти «горячую» функцию либо блокировку.  
3. Оптимизировать код.  
4. Перезапустить тест/бенч и проверить улучшение.  

---

### go tool pprof

```go
// Съём CPU-профиля
f, _ := os.Create("cpu.prof")
pprof.StartCPUProfile(f)
time.Sleep(10 * time.Second)
pprof.StopCPUProfile()
````

```bash
# Анализ
go tool pprof -http=:0 ./app cpu.prof   # web-GUI
go tool pprof cpu.prof                 # CLI
(pprof) top          # топ «горячих» функций
(pprof) list MyFunc  # ассемблер + исходник
(pprof) svg > graph.svg
```

> [!tip]  
> Собирайте бинарь с `-gcflags="all=-N -l"`: отключённый inline гарантирует точные адреса в профиле.

![[Pasted image 20250719032556.png]]  
![[Pasted image 20250719032739.png]]

---

### go tool trace

```bash
go test -run TestCritical -trace trace.out ./...
go tool trace trace.out
```

В браузере: **Goroutine analysis** (блокировки/свитчи) и **Network Syscalls** (ожидание сетевых вызовов).

![[Pasted image 20250719032925.png]]

---

### go tool cover

```bash
go test -coverprofile=cover.out ./...
go tool cover -func=cover.out   # таблица функций
go tool cover -html=cover.out   # цветная карта
```

![[Pasted image 20250719033111.png]]

---

### go debug

Интерактивная отладка без IDE.

|Команда|Действие|
|---|---|
|`vars`|Локальные переменные/аргументы|
|`backtrace`|Стек текущей горутины|
|`step` / `next`|Шаг с заходом / без захода|
|`break file:ln`|Брейкпоинт|
|`charts`|Лёгкий отчёт alloc/CPU (mini-pprof)|
|`memory`|Сводка heap-категорий|

```bash
go debug ./cmd/server --listen=:4000
# во втором терминале: telnet localhost 4000
(debug) break main.go:42
(debug) continue
```

![[Pasted image 20250719033325.png]]

---

## Преимущества

- **Точное CPU/heap-профилирование** без сторонних библиотек.
    
- **Визуальные trace-диаграммы** позволяют ловить блокировки и гонки.
    
- **Покрытие тестов** — объективная метрика регрессий.
    
- **Live-инспекция** (`go debug`) — вскрытие продовой реплики без Delve-setup.
    

## Практическое применение

|Сценарий|Комментарий|
|---|---|
|**Оптимизация сервиса**|Сняли CPU-профиль под нагрузкой, зарезали «хотспоты».|
|**CLI-утилита**|`pprof` нашёл лишние аллокации → +30 % скорости.|
|**Утечка памяти**|Heap-dump + `pprof heap` → забытый `time.Ticker`.|
|**CI-отчёты**|`go test -coverprofile` публикуется в Codecov.|

## Нюансы и подводные камни

> [!warning]
> 
> - **Trace overhead** — длинная запись (> 30 с) рождает гигабайты файла.
>     
> - **Cover false-negatives** — сгенерированный код без тестов искажает процент.
>     
> - **pprof требует символов** — не используйте `-ldflags "-s -w"` во время диагностики.
>     

## Рекомендации и FAQ

> [!tip]  
> Фильтруйте «шум»:  
> `pprof --nodefraction=0.03 --edgefraction=0.01 cpu.prof` показывает только 3 % самых «горячих» узлов.

> [!faq]  
> **Q:** Можно ли собирать профили в проде?  
> **A:** Да. Экспортируйте `/debug/pprof/` через `net/http/pprof`, ограничьте доступ и снизьте sample-rate.  
> **Q:** Почему `trace` показывает goroutine в stop-the-world?  
> **A:** Фаза GC-mark приостанавливает мир; уменьшите `GOGC` или оптимизируйте аллокации.

---

## Полезные ссылки

- [https://go.dev/doc/diagnostics](https://go.dev/doc/diagnostics)
    
- [https://pkg.go.dev/cmd/pprof](https://pkg.go.dev/cmd/pprof)
    
- [https://pkg.go.dev/cmd/trace](https://pkg.go.dev/cmd/trace)
    
- [https://pkg.go.dev/cmd/cover](https://pkg.go.dev/cmd/cover)
    
- [https://go.dev/doc/debug](https://go.dev/doc/debug)
    
- [https://blog.go.dev/pprof-guide](https://blog.go.dev/pprof-guide)
    

[[Форматирование и автоматический рефакторинг|Предыдущая статья]] | [[Документация и справка|Следующая статья]]