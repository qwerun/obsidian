> [!info] **Основная идея**  
> В языке Go **все параметры копируются**, даже если речь идёт о срезах, указателях или `map`. Однако некоторые типы, такие как `map` и `slice`, содержат внутренние указатели, из-за чего их поведение может напоминать передачу по ссылке. Это вызывает путаницу у многих разработчиков.
 
---

### **Краткий конспект**

- Go **не поддерживает передачу по ссылке** напрямую — всё передаётся по значению.
- Срезы и мапы передаются как **структуры-обёртки**, содержащие указатели.
- **Изменения по ссылке** к внутренним структурам видны снаружи, но **переприсваивание — нет**.
- `map` — это хэш-таблица со сложной структурой (buckets, indirect pointers).
- Важно понимать различия, чтобы избегать ненужных аллокаций и ошибок доступа.

---

### **Подробно**

#### Что значит «передаём по значению» в Go

Спецификация Go гласит:

> *"When an argument is passed to a function, the parameter receives a copy of the argument."*  
> — § Calls, Go Specification ([ссылка](https://go.dev/doc/go1.17_spec))

Пример:

```go
func inc(x int) {
	x++
}

func main() {
	val := 10
	inc(val)
	fmt.Println(val) // 10 — копия, не изменился
}
````

> Даже если параметр изменяется внутри функции — внешняя переменная не пострадает, потому что была передана копия.

---

#### Передача примитивных типов vs pointer/struct

Примитивы (int, bool, string) — копируются напрямую:

```go
func double(x int) int {
	return x * 2
}
```

Структуры — тоже копируются **полностью**, включая вложенные поля. Но если структура большая, это может быть дорого:

```go
type Data struct {
	A [1000]int
}

func process(d Data) {} // лучше передавать *Data
```

> [!tip]  
> В таких случаях эффективнее использовать указатели (`*Data`), чтобы избежать излишнего копирования.

---

#### Срезы: копируется header, а не данные

Срез в Go — это структура:

```go
type slice struct {
	ptr *T    // указатель на начало массива
	len int   // длина
	cap int   // вместимость
}
```

Когда мы передаём срез в функцию, копируется **только заголовок** (header), а не сам массив:

```go
func change(s []int) {
	s[0] = 100     // изменит оригинал
	s = append(s, 200) // изменит только копию header
}

func main() {
	data := []int{1, 2, 3}
	change(data)
	fmt.Println(data) // [100 2 3]
}
```

> [!example]  
> Даже несмотря на «копирование», доступ по `s[0]` влияет на исходный массив, так как `ptr` указывает на те же данные.

---

#### Map: что именно копируется, как устроены `hmap`/`bmap`

Карты (`map`) в Go — это указатели на хэш-таблицы (`hmap`), которые включают:

- список бакетов (`bmap`)
    
- размер, флаг конкаренции
    
- маску размера (`2^n - 1`)
    
- индексы (8×8 байтовых слотов на `bucket`)
    

Когда вы передаёте `map` в функцию, копируется **заголовок структуры**, содержащий указатели на бакеты.

```go
func mutate(m map[string]int) {
	m["a"] = 999 // изменение видимо снаружи
	m = map[string]int{"x": 1} // только внутренняя переменная
}

func main() {
	data := map[string]int{"a": 1}
	mutate(data)
	fmt.Println(data) // map[a:999]
}
```

> [!example]  
> Мутация содержимого `map` внутри функции затрагивает оригинал, но полное переопределение `map` — нет.

---

#### Нюансы & подводные камни

> [!warning]  
> Частые ошибки и их последствия:
> 
> - ❌ _Изменение map внутри функции влияет на оригинал_ — если не ожидалось, это может привести к багам.
>     
> - ❌ _Передача большого struct по значению_ — приведёт к лишним аллокациям.
>     
> - ❌ _Попытка передать &map_ — не нужно, map и так содержит указатель.
>     
> - ❌ _Модификация slice после `append`_ — может повлиять на неожиданные части памяти, если capacity была превышена.
>     

---

#### Практические рекомендации

> [!tip]  
> Полезные советы:
> 
> - Используйте указатели (`*T`) для больших структур.
>     
> - Не передавайте `map` как `&map` — это избыточно.
>     
> - Помните: `slice` и `map` ведут себя как **указатели**, но не являются таковыми.
>     
> - Для мутабельных операций делайте явные копии `map`/`slice`, если нужно сохранить оригинал.
>     
> - Следите за `append` — оно может выделить новый массив, а может нет.
>     

---

#### FAQ

> [!faq]  
> **Q:** Нужно ли передавать `&map[string]int` в функцию?  
> **A:** Нет, `map` и так содержит указатель на структуру — передача `&map` избыточна.
> 
> **Q:** Почему изменения `map` внутри функции видны снаружи?  
> **A:** Потому что копируется заголовок, а не содержимое — и оба указывают на одни и те же `buckets`.
> 
> **Q:** Что безопаснее передавать по значению — `map` или `slice`?  
> **A:** Оба безопасны, если понимаете, что мутации повлияют на оригинал; переприсвоения — нет.

---

### **Полезные ссылки**

- [The Go Programming Language Specification (Calls)](https://go.dev/doc/go1.17_spec)
    
- [Effective Go: Pointers vs Values](https://go.dev/doc/effective_go#pointers_vs_values)
    
- [Stack Overflow: map mutation vs reassignment](https://stackoverflow.com/questions/44486749/strange-mutation-of-map-when-passed-value-vs-when-passed-by-reference-golang)
    
- [Dave Cheney: How the Go runtime implements maps efficiently](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics)
 