> [!info] **Основная идея** Интерфейс `error` — фундаментальная часть языка Go, позволяющая описывать, обрабатывать и передавать ошибки между функциями, модулями и сервисами. Грамотная работа с ошибками повышает надёжность системы, облегчает отладку и делает API понятным.

---

## Краткий конспект

- Интерфейс `error` — контракт с методом `Error() string`, реализуемый любым типом.
    
- Базовые способы создания ошибок: `errors.New`, `fmt.Errorf`, `panic/recover` — в особых случаях.
    
- С версии Go 1.13 — поддержка обёртывания (`%w`) и распаковки (`errors.Is`, `errors.As`).
    
- Хорошая практика — создание кастомных типов ошибок с контекстом.
    
- Публичные и приватные ошибки помогают отделить внутренние детали от внешнего API.
    
- Важно логировать ошибки с контекстом и покрывать обработку ошибок в тестах.
    

---

## Что такое интерфейс `error` и зачем он нужен

Интерфейс `error` в Go описывается очень просто:

```
type error interface {
	Error() string
}
```

Любой тип, реализующий метод `Error() string`, считается ошибкой. Это позволяет возвращать ошибки в значениях, а не выбрасывать исключения, как в других языках.

> [!example] Ошибка создаётся и возвращается как обычное значение:

```
func Divide(a, b int) (int, error) {
	if b == 0 {
		return 0, errors.New("division by zero")
	}
	return a / b, nil
}
```

---

## Базовые техники обработки ошибок

Go поощряет явную проверку ошибок сразу после вызова функции:

```
res, err := DoSomething()
if err != nil {
	log.Println("ошибка при выполнении:", err)
	return err
}
```

### Основные функции:

- `errors.New("..."`) — создаёт новую ошибку
    
- `fmt.Errorf("context: %v", err)` — добавляет контекст
    
- `panic` / `recover` — для truly exceptional situations
    

> [!warning] Не злоупотребляйте `panic`: это не способ обработки обычных ошибок. Используйте его только для багов и нарушений инвариантов.

---

## Расширенные подходы: обёртывание, кастомные типы

С Go 1.13 появился встроенный механизм обёртывания ошибок:

```
err := fmt.Errorf("failed to open file: %w", baseErr)
```

Теперь можно использовать `errors.Is` и `errors.As`:

```
if errors.Is(err, os.ErrNotExist) {
	// файл не найден
}
```

Создание своих типов ошибок:

```
type NotFoundError struct {
	Resource string
}

func (e NotFoundError) Error() string {
	return fmt.Sprintf("%s not found", e.Resource)
}
```

> [!tip] Используйте `errors.As` для извлечения конкретного типа ошибки:

```
var nfErr NotFoundError
if errors.As(err, &nfErr) {
	log.Println("Не найдено:", nfErr.Resource)
}
```

---

## Обмен ошибками между пакетами и микросервисами

### Публичные и приватные ошибки

- **Публичные ошибки** — экспортируются (`var ErrInvalidToken = errors.New(...)`) и сравниваются через `errors.Is`.
    
- **Приватные** — создаются внутри пакета, не экспортируются, могут быть обёрнуты.
    

```
// auth/errors.go
var ErrUnauthorized = errors.New("unauthorized")

// внутри другого пакета:
if errors.Is(err, auth.ErrUnauthorized) {
	// вернуть 401 клиенту
}
```

> [!warning] Не передавайте внутренние детали (например, SQL-ошибки) напрямую в HTTP-ответ — оборачивайте и мапьте на доменные ошибки.

---

## Логирование и трассировка стека

Пакет `github.com/pkg/errors` (до Go 1.13) и теперь `fmt.Errorf` позволяют сохранять цепочку вызовов.

С Go 1.20+ — `errors.Join` объединяет несколько ошибок:

```
err := errors.Join(ioErr, dbErr)
```

Для логирования:

```
log.Printf("ошибка при сохранении: %v", err)
```

Для трассировки используйте:

- логгеры с поддержкой stacktrace (например, zap, zerolog)
    
- middleware, оборачивающие ошибки с контекстом запроса
    

> [!tip] Не бойтесь писать собственные типы ошибок с дополнительными полями (код, идентификатор и т.п.) — это помогает при логировании и ответах API.

---

## Тестирование сценариев ошибок

В unit-тестах важно проверять, как система реагирует на ошибки:

```
func TestLoadData_NotFound(t *testing.T) {
	_, err := LoadData("missing_id")
	if !errors.Is(err, ErrNotFound) {
		t.Errorf("ожидалась ошибка ErrNotFound, а получили: %v", err)
	}
}
```

> [!example] В тестах можно мокать зависимости, возвращающие заранее определённые ошибки, и проверять реакцию кода.

---

> [!faq]  
> **Q:** Нужно ли всегда использовать обёртывание `%w`?  
> **A:** Да, если хотите сохранить возможность различать типы ошибок с помощью `errors.Is` и `errors.As`.
> 
> **Q:** Стоит ли логировать каждую ошибку?  
> **A:** Нет. Логируйте только в одном месте — либо где ошибка произошла, либо где она обрабатывается.
> 
> **Q:** Что лучше: ошибки как строки или кастомные типы?  
> **A:** Кастомные типы дают больше контроля, но строки подойдут для простых случаев.

---

## Полезные ссылки

- https://go.dev/blog/go1.13-errors
    
- https://pkg.go.dev/errors
    
- https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully
    
- https://go.dev/ref/spec#Errors
    
- https://go.dev/blog/error-handling-and-go
