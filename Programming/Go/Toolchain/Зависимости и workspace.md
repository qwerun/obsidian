## Основная идея

> [!info]  
> **Управление зависимостями в Go** строится вокруг трёх инструментов:  
> • **`go mod`** — создаёт и обслуживает `go.mod`, фиксируя версии и контрольные суммы в `go.sum`.  
> • **`go get`** — подключает или обновляет пакет/версию, одновременно скачивая код в кеш.  
> • **`go work`** — объединяет несколько модулей в единое рабочее пространство без `replace`, что удобно для монореп и семейства сервисов.  
> Вместе они отвечают на вопросы «что скачать, какую версию и где искать» — от локального кеша до корпоративного proxy.

---

## Краткий конспект

- **`go mod`** — инициализация, tidy-чистка, вендоринг, скачивание, проверка хешей.
    
- **`go get`** — точечное подключение/обновление зависимостей, управление версиями.
    
- **`go work`** — локальная «монорепа» без публикации промежуточных версий.
    
- **Преимущества**: детерминируемые сборки, быстрая работа с офлайн-кешем, упрощённая коллаборация.

---

## Подробно

### Что такое зависимости и workspace в Go?

С Go 1.11 экосистема перешла от жёсткой структуры **GOPATH** к **go modules**. Исходники теперь могут лежать где угодно, а версии фиксируются в `go.mod`, контрольные суммы — в `go.sum`. Начиная с Go 1.18 появился `go work`, делающий совместную разработку нескольких модулей ещё проще.

---

### `go mod`

|Подкоманда|Назначение|Пример|
|---|---|---|
|**`init`**|Создать `go.mod`, указав имя модуля.|`go mod init example.com/app`|
|**`tidy`**|Добавить недостающие / удалить неиспользуемые зависимости.|`go mod tidy`|
|**`vendor`**|Скопировать нужные версии в каталог `./vendor`.|`go mod vendor`|
|**`download`**|Скачать модули в кеш без сборки.|`go mod download all`|
|**`verify`**|Проверить хеши из `go.sum` ↔ кеш.|`go mod verify`|

```go
// go.mod
module example.com/app

go 1.22
require github.com/google/uuid v1.5.0
```

`go.sum` хранит SHA-256 каждой версии; при сборке компилятор сверяет их и предупреждает о подмене.

---

### `go get`

Добавляет или обновляет зависимость **и** фиксирует её версию:

```bash
go get github.com/gorilla/mux@v1.8.1   # точно эта версия
go get -u ./...                        # обновить всё до новых minor/patch
go get -d github.com/pack/only@latest  # скачать, но не писать в go.mod
```

> [!faq]  
> **Q:** Когда вместо `go install`?  
> **A:** `go get` меняет ваш проект, записывая зависимость в `go.mod`.  
> `go install pkg@ver` ставит CLI-утилиту в `$GOBIN` **без** изменений проекта.

---

### `go work`

Позволяет связать несколько модулей, избегая громоздких `replace`-директив:

```bash
go work init ./service-a ./lib-common
```

```go
// go.work
go 1.22

use (
    ./service-a
    ./lib-common
)
```

Изменения в `lib-common` сразу доступны `service-a`, без публикации промежуточных версий.  
Сценарии: монорепа, микросервисы, SDK + примеры, постепенный переход на модули.

---

### Нюансы и подводные камни

> [!warning]
> 
> - **Дрифт версий** — забытый `go mod tidy` приводит к «зомби»-зависимостям.
>     
> - **Глубокие цепочки транзитивных модулей** могут увеличить время сборки; следите за размером кеша.
>     
> - **Смешение `replace` и `go work`** порой ломает reproducible-сборку; используйте что-то одно.
>     

### Рекомендации и FAQ

> [!tip]  
> Ставьте `GOMODCACHE` на быстрый SSD и прогоняйте `go mod verify` в CI — это рано ловит проблемы с хешами.

> [!faq]  
> **Q:** Как работать офлайн?  
> **A:** Скачайте всё нужное заранее (`go mod download all`) — компилятор возьмёт модули из кеша.  
> **Q:** Нужен ли `vendor` в 2025?  
> **A:** Для публичных проектов — редко; для закрытых окружений без интернета или с air-gap-CI — всё ещё полезен.  
>

---

## Полезные ссылки

- [https://go.dev/ref/mod](https://go.dev/ref/mod)
    
- [https://pkg.go.dev/cmd/go](https://pkg.go.dev/cmd/go)
    
- [https://blog.go.dev/using-go-modules](https://blog.go.dev/using-go-modules)


[[Сборка и запуск|Предыдущая статья]] | [[Тестирование и анализ качества|Следующая статья]]