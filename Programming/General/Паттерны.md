> [!info] Основная идея  
> **Factory**, **Singleton** и **Decorator** помогают управлять зависимостями и поведением объектов в Go‑коде

---

## Краткий конспект

- **Factory** — создаёт объекты через единую точку; упрощает замену реализаций.
    
- **Singleton** — даёт одну общую «глобальную» структуру; удобно для конфигураций, кэшей.
    
- **Decorator** — оборачивает объект, добавляя новые возможности; позволяет комбинировать поведение во время выполнения.
    

---

### Паттерн Factory

Короткое определение: _функция или тип, возвращающий интерфейс, пряча детали создания конкретных структур_.

```go
package main

import "fmt"

type Transport interface{ Move() string }

type car  struct{}; func (car)  Move() string { return "еду на машине" }
type bike struct{}; func (bike) Move() string { return "еду на велосипеде" }

func NewTransport(kind string) Transport {
	switch kind {
	case "car":  return car{}
	case "bike": return bike{}
	default:     panic("unknown transport")
	}
}

func main() {
	t := NewTransport("car")
	fmt.Println(t.Move())
}
```

- **Плюсы**
    
    - Инкапсулирует сложное создание объектов
        
    - Легко подменять реализации (тесты, плагины)
        
    - Снижает связность между пакетом‑клиентом и конкретными типами
        
- **Минусы**
    
    - Дополнительный слой абстракции усложняет читаемость
        
    - Ошибки выбора вида часто обнаруживаются во время выполнения, а не компиляции
        
    - При росте вариантов фабричная функция может раздуться
        

### Паттерн Singleton

Короткое определение: _гарантирует, что структура создастся один раз и будет доступна глобально_.

```go
package config

import "sync"

type Config struct{ DSN string }

var (
	once     sync.Once
	instance *Config
)

func Get() *Config {
	once.Do(func() {
		instance = &Config{DSN: "postgres://user@localhost/db"}
	})
	return instance
}
```

- **Плюсы**
    
    - Одна точка доступа к разделяемым ресурсам (конфиг, кэш)
        
    - Ленивая инициализация без гонок благодаря `sync.Once`
        
    - Экономия памяти и упрощённое хранение состояния
        
- **Минусы**
    
    - По сути глобальная переменная — прячет зависимости
        
    - Труднее писать изолированные тесты
        
    - Не подходит для случаев, где нужны разные экземпляры (мультикластер, шардинг)
        

### Паттерн Decorator

Короткое определение: _объект‑обёртка, реализующий тот же интерфейс и добавляющий новое поведение перед/после вызова_.

```go
package main

import "fmt"

type Notifier interface{ Notify(msg string) }

type email struct{}
func (email) Notify(msg string) { fmt.Println("email:", msg) }

type withSlack struct{ Notifier }
func (d withSlack) Notify(msg string) {
	d.Notifier.Notify(msg)       // базовое поведение
	fmt.Println("slack:", msg)   // новое
}

func main() {
	n := withSlack{Notifier: email{}}
	n.Notify("build passed")
}
```

- **Плюсы**
    
    - Расширяет функциональность без изменения исходного кода и интерфейса
        
    - Позволяет динамически комбинировать наборы обёрток
        
    - Избегает взрыва количества наследуемых типов (чего нет в Go)
        
- **Минусы**
    
    - Добавляет уровень вложенности, усложняя отладку стека вызовов
        
    - Увеличивает число маленьких объектов и может влиять на сбор мусора
        
    - Требует дисциплины, чтобы порядок обёрток оставался предсказуемым
        

> [!tip]  
> В Go удобнее делать «функциональные» декораторы (возвращающие `func(…)`) для HTTP‑хендлеров или middleware.

---

## Полезные ссылки

- Refactoring Guru — [Factory Method (Go)](https://refactoring.guru/design-patterns/factory-method/go/example?utm_source=chatgpt.com)
    
- Refactoring Guru — [Singleton (Go)](https://refactoring.guru/design-patterns/singleton/go/example?utm_source=chatgpt.com)
    
- Medium — «[Golang — Decorator Pattern](https://medium.com/%40MTrax/golang-decorator-pattern-87b5aecc28d7?utm_source=chatgpt.com)»
