## Основная идея

> [!info]  
> **CGO** — встроенный инструмент, который даёт программам на Go возможность напрямую обращаться к коду на C и обратно.  
> - Можно использовать тысячи готовых C-библиотек.  
> - Цена — более сложная сборка и частичная потеря «чистоты» Go-кода.

---

## Краткий конспект

- CGO объединяет Go-код с C-кодом во время сборки.  
- Позволяет вызывать C-функции и работать с их структурами и указателями.  
- Полезен, когда нет быстрых или полноценных аналогов на Go.  
- `CGO_ENABLED=0/1` включает или отключает CGO.  
- Без CGO кросс-сборка обычно сводится к `go build -o app`.  
- Используйте CGO точечно, если выгода перекрывает издержки.

---

### Связь с компилятором

> [!tip]  
> Программисту не нужно запускать CGO вручную: достаточно добавить `import "C"`.

## Как работает CGO?

1. **Чтение Go-файла** — в комментарии над `import "C"` можно писать `#include`, `#cgo CFLAGS:` и другие директивы.  
2. **Генерация файлов-обёрток** — `cmd/cgo` создаёт Go- и C-файлы, скрывающие детали вызовов.  
3. **Компиляция** — Go-часть компилирует `gc`, C-часть — системный `gcc` или `clang`.  
4. **Линковка** — специальная программа склеивает все объектные файлы и создаёт итоговый бинарь.  
5. **Работа во время исполнения**  
   - При переходе Go → C переключается стек.  
   - Планировщик Go помечает поток как «занят внешним вызовом», что может замедлить параллельность.  
   - Go-указатели нельзя хранить в C-коде дольше вызова; для небезопасных операций нужен `unsafe.Pointer`.

> [!example]  
> Минимальный вызов C-функции  
> ```go
> // hello.go
> package main
> /*
> #include <stdio.h>
> void hi() { puts("Привет из C!"); }
> */
> import "C"
> 
> func main() { C.hi() }
> ```

## Недостатки и ограничения

1. **Дольше сборка** — дополнительные вызовы C-компилятора и линкера.  
2. **Больше бинарь** — в статический файл попадает часть стандартной C-библиотеки.  
3. **Сложнее отладка и профилирование** — стек-трейсы «рвутся».  
4. **Риск утечек памяти** — C-код не знает о сборщике мусора Go.

## Практическое применение

1. **Обёртка нативных библиотек** — например, libgit2-go или go-sqlite3.  
2. **Интеграция старого кода** — постепенный перенос большого проекта с C на Go.

## Нюансы и подводные камни

> [!warning]  
> - **Указатели** нельзя хранить в C-переменных дольше одного вызова.  
> - **Сигналы**: C-код может поймать ошибку раньше Go-рантайма, и вы потеряете нормальный отчёт.  
> - **GOMAXPROCS**: долгий вызов C блокирует поток и уменьшает параллельность Go-приложения.

## FAQ

**Q:** Откуда берётся огромный бинарь?  
**A:** В него добавляются части C-библиотек. Попробуйте динамическую линковку (`-ldflags "-linkmode=external"`) или отключите CGO.  

**Q:** Дает ли CGO прирост скорости?  
**A:** Иногда, если сама C-функция тяжёлая. Частые короткие вызовы могут замедлять программу из-за переключения стеков.

---

## Полезные ссылки

- Официальная документация [`cmd/cgo`](https://pkg.go.dev/cmd/cgo)  
- Go Wiki: [cgo](https://go.dev/wiki/cgo)  
- Dave Cheney — «cgo is not Go»  
- Mike Glukhovsky — «Cgo: When and (Usually) When Not to Use it»  

> [!tip]  
> Хотите собрать бинарь под Linux x86_64 с macOS?  
> ```bash
> CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o app-linux
> ```
