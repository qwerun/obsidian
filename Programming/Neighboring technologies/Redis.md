> [!info]  
> **Основная идея** — Redis нужен, чтобы ускорять доступ к часто используемым данным за счёт хранения их в оперативной памяти. Показатель _cache hit_ отражает эффективность кеша.
 
---

## Краткий конспект

- Redis — это in-memory хранилище, работающее с миллисекундными задержками.
    
- _Cache hit_ показывает, насколько часто нужные данные уже в кеше.
    
- Хороший кеш ускоряет рендеринг страниц, API-ответы и сокращает нагрузку на БД.
    
- Redis поддерживает структуры данных: списки, множества, хэши, строки.
    
- При плохой стратегии кеш может стать источником ошибок или замедления.
    
- Интервьюеры ценят знание pub/sub, persistence-моделей и оценки производительности.
    

---

## Что такое Redis и зачем он нужен?

Redis появился как быстрый in-memory-ключ-значение стор, ориентированный на простоту и высокую производительность. Он работает из оперативной памяти, что позволяет обслуживать запросы за доли миллисекунды.

**Зачем нужен Redis?**

- Я бы отметил его как промежуточный уровень между медленной БД и быстрым доступом.
    
- Redis особенно полезен при кешировании, очередях задач, счётчиках, хранении сессий и блокировках.
    

> [!example]  
> Пользователь впервые открывает товар — данные идут из БД и записываются в Redis. При повторных запросах чтение идёт из кеша.

---

## Cache hit vs cache miss

**Cache hit** — это ситуация, когда нужные данные уже есть в кеше.  
**Cache miss** — данные отсутствуют и приходится обращаться к основному хранилищу.

**Формула hit ratio:**

```
hit_ratio = keyspace_hits / (keyspace_hits + keyspace_misses)
```

Посмотреть статистику можно так:

```bash
redis-cli INFO stats
```

Фрагмент вывода:

```
keyspace_hits:25013
keyspace_misses:873
```

> [!tip]  
> На собеседовании важно сказать, что _низкий cache hit_ означает лишнюю нагрузку на БД. Это видно в метриках — рост времени ответа, всплески обращений к основному источнику.

---

## Преимущества Redis на собеседовании

**Что стоит упомянуть:**

- **Скорость** — операции в памяти обычно укладываются в 1 мс.
    
- **Богатые типы данных** — строки, списки, множества, хэши, bitmaps.
    
- **Поддержка pub/sub** — удобно для событийной архитектуры.
    
- **Persistence** — Redis поддерживает снапшоты (`RDB`) и журналирование (`AOF`).
    
- **Atomic operations** — большинство операций атомарны, что важно при параллельной работе.
    

> [!example]  
> Я бы отметил, что Redis хорош для read-heavy систем, когда важно быстро отдавать результат, например, в API с большим количеством GET-запросов.

---

## Когда кеш вредит производительности

Даже Redis может ухудшить систему, если использовать его без стратегии. Вот типичные сценарии:

1. **Большой объём данных превышает размер RAM**  
    Redis начинает вытеснять данные по [[Redis#LRU (Least Recently Used)|LRU/TTL]], но это вызывает постоянные cache miss.  
    → Симптом: рост латентности, частые обращения к БД.
    
2. **Рассинхронизация кеша и источника данных**  
    Особенно критично при write-heavy нагрузке: данные изменились, а в кеше — устаревшие.  
    → Нужно использовать write-through.
    Если нет write‑through - Берите **Cache‑Aside + инвалидация**:  Записываем в БД → 2) удаляем ключ (лучше дважды) → 3) кэш наполняется >свежим по первому чтению.
    
3. **Cold-start**  
    После рестарта Redis пустой, и все запросы идут мимо кеша.  
    → Решение: preload из БД или периодический refresh.
    
4. **Write-through overhead**  
    Попытка сразу писать и в Redis, и в основную БД может замедлить систему и усложнить отладку.
    

> [!tip]  
> Я бы упомянул, что эти проблемы часто видны в метриках `INFO`, `MONITOR` и системах наблюдаемости (например, [[Observability|Prometheus + Grafana]]).

---

### LRU (Least Recently Used)

**Определение:** стратегия вытеснения, при которой удаляется объект, к которому обращались раньше всех.  
**Применяется:** когда объём кэша ограничен и нужно освобождать место, сохраняя «горячие» данные.

### TTL (Time To Live)

**Определение:** срок жизни объекта; по его истечении объект считается недействительным и удаляется.  
**Используется:** чтобы данные не устаревали и кэш не переполнялся.

> [!summary]  
> **LRU** удаляет наименее недавно использованный элемент, ориентируясь на активность.  
> **TTL** удаляет элемент по истечении фиксированного времени, ориентируясь на возраст.

---

## Типичные вопросы рекрутера

> [!faq]  
> **Q:** Как гарантировать консистентность между Redis и БД?  
> **A:** Использовать write-through или write-behind с надёжной логикой инвалидации.
>
> **Q:** Чем Redis отличается от Memcached?  
> **A:** Redis поддерживает структуры данных и [[Персистентность в Redis|персистентность]], Memcached — только строки в RAM.
>
> **Q:** Можно ли использовать Redis как основное хранилище?  
> **A:** Только если важна скорость и допустим риск потери данных (например, для аналитики или счётчиков).
>
> **Q:** Как измерить эффективность кеша?  
> **A:** Через hit ratio (`INFO stats`) и мониторинг ключей с высоким TTL.
>
> **Q:** Почему иногда кеш даёт _меньшую_ производительность?  
> **A:** Из-за частых промахов (miss), которые вызывают дополнительные обращения к БД.
>
> **Q:** Redis single-threaded — это плохо?  
> **A:** Нет. Благодаря in-memory и event loop он обслуживает десятки тысяч запросов в секунду.
 
---

## Практические примеры

### Проверка задержек в CLI

```bash
redis-cli --latency
```

Вывод показывает усреднённое время ответа на команды Redis. Уровень до 1 мс — норма.

---

### Read-through cache (на Go)

```go
func GetUser(ctx context.Context, id string) (User, error) {
	val, err := redisClient.Get(ctx, id).Result()
	if err == redis.Nil {
		user, err := db.LoadUser(id)
		if err != nil {
			return User{}, err
		}
		_ = redisClient.Set(ctx, id, marshal(user), time.Hour)
		return user, nil
	}
	return unmarshal(val), nil
}
```

> [!tip]  
> Этот подход позволяет автоматически подгружать данные в кеш после промаха. Аналогично реализуется фоновый preload.

---

## Нюансы и подводные камни

> [!warning]
> 
> - **TTL не всегда решает проблему устаревания** — особенно при часто изменяемых данных.
>     
> - **Много ключей с разным временем жизни** → фрагментация памяти.
>     
> - **Неправильная инвалидация** может привести к несогласованным данным.
>     
> - **Сложные структуры (например, JSON в строках)** затрудняют атомарные операции.
>     

---

> [!faq]  
> **Q:** Redis хранит всё только в памяти?  
> **A:** Да, но можно включить RDB и AOF, чтобы периодически сохранять данные на диск.
> 
> **Q:** Что будет, если Redis упадёт?  
> **A:** Без [[Персистентность в Redis|персистентности]] данные потеряются. Настройте RDB/AOF, регулярные бэкапы и мониторинг.
> 
> **Q:** Как кешировать данные с разными TTL?  
> **A:** Задавайте каждому ключу своё время жизни через `SET key value EX <seconds>` и регулярно пересматривайте стратегию TTL.
> 
> **Q:** Подходит ли Redis для очередей?  
> **A:** Да, но чаще используют kafka.

---

## Полезные ссылки

- [Официальная документация Redis](https://redis.io/docs/latest/?utm_source=chatgpt.com)
    
- [Why your cache hit ratio strategy needs an update (Redis Blog)](https://redis.io/blog/why-your-cache-hit-ratio-strategy-needs-an-update/?utm_source=chatgpt.com)
    
- [Что такое cache hit ratio? (Cloudflare)](https://www.cloudflare.com/learning/cdn/what-is-a-cache-hit-ratio/?utm_source=chatgpt.com)
    
- [Top Redis Questions (GeeksForGeeks)](https://www.geeksforgeeks.org/system-design/top-25-redis-interview-questions/?utm_source=chatgpt.com)
